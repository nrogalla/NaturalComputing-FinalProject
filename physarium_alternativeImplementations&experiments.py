# -*- coding: utf-8 -*-
"""NC_mushroom_FV.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10nNHZmTqNUwzE_qp73JWcvXYZ1Jm3Rbw

#Inizialisation physarium + dynamic programming/simulated annealing for TSP extraction

##v0: 3708
"""

!pip install tsp_solver2

import numpy as np
import gzip
import shutil

def extract_gzip(source_filepath, destination_filepath):
    with gzip.open(source_filepath, 'rb') as f_in, open(destination_filepath, 'wb') as f_out:
        shutil.copyfileobj(f_in, f_out)

def load_coordinates(file_path):
    coordinates = []
    start_reading = False
    with open(file_path, 'r') as file:
        for line in file:
            if "NODE_COORD_SECTION" in line:
                start_reading = True
            elif "EOF" in line:
                break
            elif start_reading:
                parts = line.strip().split()
                if len(parts) == 3 and parts[0].isdigit():
                    # Convert to degrees
                    lat = float(parts[1])
                    lon = float(parts[2])
                    coordinates.append((lat, lon))
    return coordinates

source_filepath = '/content/burma14.tsp.gz'
destination_filepath = 'burma14.tsp'
extract_gzip(source_filepath, destination_filepath)
cities = np.array(load_coordinates(destination_filepath))
print("Loaded coordinates for", len(cities), "cities.")

def geo_distance(coord1, coord2):
    # Haversine formula to calculate the distance between two lat/lon points
    R = 6371  # Radius of the Earth in kilometers
    lat1, lon1 = np.radians(coord1)
    lat2, lon2 = np.radians(coord2)

    dlat = lat2 - lat1
    dlon = lon2 - lon1

    a = np.sin(dlat / 2)**2 + np.cos(lat1) * np.cos(lat2) * np.sin(dlon / 2)**2
    c = 2 * np.arctan2(np.sqrt(a), np.sqrt(1 - a))

    distance = R * c
    return distance

def calculate_distances(cities):
    num_cities = len(cities)
    distances = np.zeros((num_cities, num_cities))
    for i in range(num_cities):
        for j in range(num_cities):
            distances[i, j] = geo_distance(cities[i], cities[j]) if i != j else np.inf
    return distances

distances = calculate_distances(cities)
pressures = np.random.rand(len(cities)) * 10
conductivities = np.ones_like(distances) * 0.01  # Start with a small initial value for all conductivities

decay_rate = 0.01
k = 0.1
m = 2
epsilon = 1e-10

def calculate_fluxes(pressures, conductivities, distances, epsilon=1e-10):
    num_cities = len(pressures)
    fluxes = np.zeros((num_cities, num_cities))
    for i in range(num_cities):
        for j in range(num_cities):
            if i != j:
                distance = max(distances[i][j], epsilon)  # Avoid division by zero
                delta_p = np.clip(pressures[i] - pressures[j], -1e3, 1e3)
                fluxes[i][j] = (conductivities[i][j] / distance) * delta_p
    return fluxes

def update_conductivities(conductivities, fluxes, decay_rate, k, m):
    num_cities = len(conductivities)
    for i in range(num_cities):
        for j in range(num_cities):
            if i != j:
                flux = np.clip(abs(fluxes[i][j]), 0, 1e3)  # Control the size of the flux to prevent overflow
                growth = k * (flux ** m) - decay_rate * conductivities[i][j]
                growth = np.clip(growth, -1e2, 1e2)  # Limit the growth to prevent explosive updates
                conductivities[i][j] += growth
    return conductivities

def update_pressures(pressures, fluxes, rate=0.05):
    num_cities = len(pressures)
    for i in range(num_cities):
        net_influx = np.sum(fluxes[:, i]) - np.sum(fluxes[i, :])
        pressures[i] += rate * net_influx
        pressures[i] = np.clip(pressures[i], 0, 1e2)  # Prevent pressure from becoming negative or excessively high
    return pressures

def prune_connections(conductivities, threshold=0.005):
    conductivities[conductivities < threshold] = 0
    return conductivities

# Update the simulation loop to include pressure updates
num_iterations = 50
for _ in range(num_iterations):
    fluxes = calculate_fluxes(pressures, conductivities, distances)
    pressures = update_pressures(pressures, fluxes)
    conductivities = update_conductivities(conductivities, fluxes, decay_rate, k, m)

print("Final pressures:", pressures)
print("Final conductivities:", conductivities)

import matplotlib.pyplot as plt
best_fitness = np.inf
best_path = None
best_distances = []
import networkx as nx

import networkx as nx

def extract_tsp_path(conductivities, threshold=0.005):
    # Step 1: Prune the conductivity matrix
    pruned_conductivities = np.copy(conductivities)
    pruned_conductivities[pruned_conductivities < threshold] = 0

    # Step 2: Convert the pruned conductivities to a graph
    G = nx.Graph()
    num_cities = len(conductivities)
    for i in range(num_cities):
        for j in range(i + 1, num_cities):
            if pruned_conductivities[i][j] > 0:
                G.add_edge(i, j, weight=1 / pruned_conductivities[i][j])

    if len(G.nodes) == 0:
        raise ValueError("The graph is empty after pruning. Adjust the threshold or check the conductivities.")

    # Step 3: Compute the minimum spanning tree (MST)
    MST = nx.minimum_spanning_tree(G)

    if len(MST.nodes) == 0:
        raise ValueError("The MST is empty. This might happen if the graph is disconnected.")

    # Step 4: Perform a DFS traversal of the MST to get the TSP path
    try:
        tsp_path = list(nx.dfs_preorder_nodes(MST, source=0))
    except KeyError as e:
        raise KeyError(f"Node {e} not found in MST. Ensure the graph is connected and has all nodes.")

    tsp_path.append(tsp_path[0])  # to form a complete circuit

    return tsp_path

# Replacing the placeholder extract_tsp_path function with the new one
def calculate_total_distance(path, distances):
    return sum(distances[path[i], path[i + 1]] for i in range(len(path) - 1))

# Running the simulation loop with the updated path extraction method
best_fitness = np.inf
best_path = None
best_distances = []

num_iterations = 50
for iteration in range(num_iterations):
    fluxes = calculate_fluxes(pressures, conductivities, distances)
    pressures = update_pressures(pressures, fluxes)
    conductivities = update_conductivities(conductivities, fluxes, decay_rate, k, m)
    if iteration % 500 == 0:  # Periodically prune and check for best solution
        conductivities = prune_connections(conductivities)

        try:
            current_path = extract_tsp_path(conductivities, threshold=0.005)
            current_fitness = calculate_total_distance(current_path, distances)

            if current_fitness < best_fitness:
                best_fitness = current_fitness
                best_path = current_path

            best_distances.append(best_fitness)
        except Exception as e:
            print(f"Error during path extraction: {e}")

print("Best Fitness:", best_fitness)
print("Best Path:", best_path)

# Plotting the best fitness over iterations
plt.figure(figsize=(10, 5))
plt.plot(best_distances, label='Best Fitness')
plt.xlabel('Iteration')
plt.ylabel('Total Distance (Fitness)')
plt.title('Best Fitness over Iterations')
plt.legend()
plt.show()

"""##v1: 3354"""

!pip install python-tsp

import numpy as np
import gzip
import shutil
import matplotlib.pyplot as plt
import time
from python_tsp.exact import solve_tsp_dynamic_programming

# Function to extract .gz file
def extract_gzip(source_filepath, destination_filepath):
    with gzip.open(source_filepath, 'rb') as f_in, open(destination_filepath, 'wb') as f_out:
        shutil.copyfileobj(f_in, f_out)

# Function to load coordinates from the .tsp file
def load_coordinates(file_path):
    coordinates = []
    start_reading = False
    with open(file_path, 'r') as file:
        for line in file:
            if "NODE_COORD_SECTION" in line:
                start_reading = True
            elif "EOF" in line:
                break
            elif start_reading:
                parts = line.strip().split()
                if len(parts) == 3 and parts[0].isdigit():
                    coordinates.append((float(parts[1]), float(parts[2])))
    return coordinates

# Function to calculate geographical distances using the Haversine formula
def haversine(coord1, coord2):
    # Radius of the Earth in km
    R = 6371.0
    lat1, lon1 = np.radians(coord1)
    lat2, lon2 = np.radians(coord2)

    dlat = lat2 - lat1
    dlon = lon2 - lon1

    a = np.sin(dlat / 2)**2 + np.cos(lat1) * np.cos(lat2) * np.sin(dlon / 2)**2
    c = 2 * np.arctan2(np.sqrt(a), np.sqrt(1 - a))
    distance = R * c
    return distance

# Extract and load city coordinates
source_filepath = '/content/burma14.tsp.gz'
destination_filepath = 'burma14.tsp'
extract_gzip(source_filepath, destination_filepath)
cities = np.array(load_coordinates(destination_filepath))
print("Loaded coordinates for", len(cities), "cities.")

# Calculate distance matrix
def calculate_distances(cities):
    num_cities = len(cities)
    distances = np.zeros((num_cities, num_cities))
    for i in range(num_cities):
        for j in range(num_cities):
            if i != j:
                distances[i, j] = haversine(cities[i], cities[j])
            else:
                distances[i, j] = np.inf
    return distances


distances = calculate_distances(cities)
pressures = np.random.rand(len(cities)) * 10
conductivities = np.ones_like(distances) * 0.01  # Start with a small initial value for all conductivities

decay_rate = 0.01
k = 0.1
m = 2
epsilon = 1e-10

def calculate_fluxes(pressures, conductivities, distances, epsilon=1e-10):
    num_cities = len(pressures)
    fluxes = np.zeros((num_cities, num_cities))
    for i in range(num_cities):
        for j in range(num_cities):
            if i != j:
                distance = max(distances[i][j], epsilon)  # Avoid division by zero
                delta_p = np.clip(pressures[i] - pressures[j], -1e3, 1e3)
                fluxes[i][j] = (conductivities[i][j] / distance) * delta_p
    return fluxes

def update_conductivities(conductivities, fluxes, decay_rate, k, m):
    num_cities = len(conductivities)
    for i in range(num_cities):
        for j in range(num_cities):
            if i != j:
                flux = np.clip(abs(fluxes[i][j]), 0, 1e3)  # Control the size of the flux to prevent overflow
                growth = k * (flux ** m) - decay_rate * conductivities[i][j]
                growth = np.clip(growth, -1e2, 1e2)  # Limit the growth to prevent explosive updates
                conductivities[i][j] += growth
    return conductivities

def update_pressures(pressures, fluxes, rate=0.05):
    num_cities = len(pressures)
    for i in range(num_cities):
        net_influx = np.sum(fluxes[:, i]) - np.sum(fluxes[i, :])
        pressures[i] += rate * net_influx
        pressures[i] = np.clip(pressures[i], 0, 1e2)  # Prevent pressure from becoming negative or excessively high
    return pressures

def prune_connections(conductivities, threshold=0.005):
    conductivities[conductivities < threshold] = 0
    return conductivities

# Function to extract a TSP path using python-tsp
def extract_tsp_path(conductivities, distances):
    adjusted_distances = np.where(conductivities > 0, distances, np.inf)
    permutation, distance = solve_tsp_dynamic_programming(adjusted_distances)
    return permutation, distance

# Function to calculate the total distance of a given path
def calculate_total_distance(path, distances):
    total_distance = 0
    for i in range(len(path) - 1):
        if distances[path[i], path[i + 1]] == np.inf:
            print(f"Invalid distance between {path[i]} and {path[i + 1]}")
            return np.inf
        total_distance += distances[path[i], path[i + 1]]
    # Add the distance to return to the starting point
    if distances[path[-1], path[0]] == np.inf:
        print(f"Invalid distance between {path[-1]} and {path[0]}")
        return np.inf
    total_distance += distances[path[-1], path[0]]
    return total_distance

# Function to calculate memory usage
def calculate_memory_usage(conductivities):
    return conductivities.nbytes

# Simulation loop with best solution tracking and additional performance measures
num_iterations = 50
best_fitness = np.inf
best_path = None
best_distances = []
computation_times = []
convergence_rates = []
memory_usages = []
all_solutions = []

start_time = time.time()

for iteration in range(num_iterations):
    iteration_start_time = time.time()

    fluxes = calculate_fluxes(pressures, conductivities, distances)
    pressures = update_pressures(pressures, fluxes)
    conductivities = update_conductivities(conductivities, fluxes, decay_rate, k, m)

    iteration_end_time = time.time()
    computation_times.append(iteration_end_time - iteration_start_time)

    if iteration % 10 == 0:  # Periodically prune and check for best solution
        conductivities = prune_connections(conductivities)
        current_path, current_fitness = extract_tsp_path(conductivities, distances)
        print(f"Iteration {iteration}, Current Path: {current_path}, Current Fitness: {current_fitness}")
        all_solutions.append(current_fitness)

        if current_fitness < best_fitness:
            best_fitness = current_fitness
            best_path = current_path

        best_distances.append(best_fitness)
        convergence_rates.append(best_fitness)
        memory_usages.append(calculate_memory_usage(conductivities))

        # Print the length of the tour for the current best path
        if best_path is not None:
            tour_length = calculate_total_distance(best_path, distances)
            print(f"Iteration {iteration}, Best Path Length: {tour_length}")

total_computation_time = time.time() - start_time

print("Best Fitness:", best_fitness)
print("Best Path:", best_path)
print("Total Computation Time:", total_computation_time, "seconds")
print("Average Computation Time per Iteration:", np.mean(computation_times), "seconds")
print("Memory Usage:", memory_usages[-1], "bytes")

"""##v2: 3354"""

import numpy as np
import gzip
import shutil
import matplotlib.pyplot as plt
import time
from python_tsp.exact import solve_tsp_dynamic_programming

# Function to extract .gz file
def extract_gzip(source_filepath, destination_filepath):
    with gzip.open(source_filepath, 'rb') as f_in, open(destination_filepath, 'wb') as f_out:
        shutil.copyfileobj(f_in, f_out)

# Function to load coordinates from the .tsp file
def load_coordinates(file_path):
    coordinates = []
    start_reading = False
    with open(file_path, 'r') as file:
        for line in file:
            if "NODE_COORD_SECTION" in line:
                start_reading = True
            elif "EOF" in line:
                break
            elif start_reading:
                parts = line.strip().split()
                if len(parts) == 3 and parts[0].isdigit():
                    coordinates.append((float(parts[1]), float(parts[2])))
    return coordinates

# Function to calculate geographical distances using the Haversine formula
def haversine(coord1, coord2):
    R = 6371.0  # Radius of the Earth in km
    lat1, lon1 = np.radians(coord1)
    lat2, lon2 = np.radians(coord2)
    dlat = lat2 - lat1
    dlon = lon2 - lon1
    a = np.sin(dlat / 2)**2 + np.cos(lat1) * np.cos(lat2) * np.sin(dlon / 2)**2
    c = 2 * np.arctan2(np.sqrt(a), np.sqrt(1 - a))
    distance = R * c
    return distance

# Extract and load city coordinates
source_filepath = '/content/burma14.tsp.gz'
destination_filepath = 'burma14.tsp'
extract_gzip(source_filepath, destination_filepath)
cities = np.array(load_coordinates(destination_filepath))
print("Loaded coordinates for", len(cities), "cities.")

# Calculate distance matrix
def calculate_distances(cities):
    num_cities = len(cities)
    distances = np.zeros((num_cities, num_cities))
    for i in range(num_cities):
        for j in range(num_cities):
            if i != j:
                distances[i, j] = haversine(cities[i], cities[j])
            else:
                distances[i, j] = np.inf
    return distances

distances = calculate_distances(cities)
print("Distance matrix:")
print(distances)

# Initialize pressures and conductivities
pressures = np.random.rand(len(cities)) * 10
conductivities = np.ones_like(distances) * 0.01  # Initial small value for all conductivities

decay_rate = 0.01
k = 0.1
m = 2
epsilon = 1e-10

# Function to calculate fluxes
def calculate_fluxes(pressures, conductivities, distances, epsilon=1e-10):
    num_cities = len(pressures)
    fluxes = np.zeros((num_cities, num_cities))
    for i in range(num_cities):
        for j in range(num_cities):
            if i != j:
                distance = max(distances[i][j], epsilon)  # Avoid division by zero
                delta_p = np.clip(pressures[i] - pressures[j], -1e3, 1e3)  # Ensure pressures do not cause overflow
                fluxes[i][j] = (conductivities[i][j] / distance) * delta_p
    return fluxes

# Function to update conductivities
def update_conductivities(conductivities, fluxes, decay_rate, k, m):
    num_cities = len(conductivities)
    for i in range(num_cities):
        for j in range(num_cities):
            if i != j:
                flux = np.clip(abs(fluxes[i][j]), 0, 1e3)  # Control the size of the flux to prevent overflow
                growth = k * (flux ** m) - decay_rate * conductivities[i][j]
                growth = np.clip(growth, -1e2, 1e2)  # Limit the growth to prevent explosive updates
                conductivities[i][j] += growth + np.random.rand() * 0.001  # Add randomness to explore more paths
    return conductivities

# Function to update pressures
def update_pressures(pressures, fluxes, rate=0.05):
    num_cities = len(pressures)
    for i in range(num_cities):
        net_influx = np.sum(fluxes[:, i]) - np.sum(fluxes[i, :])
        pressures[i] += rate * net_influx
        pressures[i] = np.clip(pressures[i], 0, 1e2)  # Prevent pressure from becoming negative or excessively high
    return pressures

# Function to prune connections
def prune_connections(conductivities, threshold=0.005):
    conductivities[conductivities < threshold] = 0
    return conductivities

# Function to extract a TSP path using python-tsp
def extract_tsp_path(conductivities, distances):
    adjusted_distances = np.where(conductivities > 0, distances, np.inf)
    permutation, distance = solve_tsp_dynamic_programming(adjusted_distances)
    return permutation, distance

# Function to calculate the total distance of a given path
def calculate_total_distance(path, distances):
    total_distance = 0
    for i in range(len(path) - 1):
        if distances[path[i], path[i + 1]] == np.inf:
            print(f"Invalid distance between {path[i]} and {path[i + 1]}")
            return np.inf
        total_distance += distances[path[i], path[i + 1]]
    # Add the distance to return to the starting point
    if distances[path[-1], path[0]] == np.inf:
        print(f"Invalid distance between {path[-1]} and {path[0]}")
        return np.inf
    total_distance += distances[path[-1], path[0]]
    return total_distance

# Function to calculate memory usage
def calculate_memory_usage(conductivities):
    return conductivities.nbytes

# Simulation loop with best solution tracking and additional performance measures
num_iterations = 500
best_fitness = np.inf
best_path = None
best_distances = []
computation_times = []
convergence_rates = []
memory_usages = []
all_solutions = []

start_time = time.time()

for iteration in range(num_iterations):
    iteration_start_time = time.time()

    fluxes = calculate_fluxes(pressures, conductivities, distances)
    pressures = update_pressures(pressures, fluxes)
    conductivities = update_conductivities(conductivities, fluxes, decay_rate, k, m)

    iteration_end_time = time.time()
    computation_times.append(iteration_end_time - iteration_start_time)

    if iteration % 5 == 0:  # Periodically prune and check for best solution
        conductivities = prune_connections(conductivities)
        current_path, current_fitness = extract_tsp_path(conductivities, distances)
        print(f"Iteration {iteration}, Current Path: {current_path}, Current Fitness: {current_fitness}")
        all_solutions.append(current_fitness)

        if current_fitness < best_fitness:
            best_fitness = current_fitness
            best_path = current_path

        best_distances.append(best_fitness)
        convergence_rates.append(best_fitness)
        memory_usages.append(calculate_memory_usage(conductivities))

        # Print the length of the tour for the current best path
        if best_path is not None:
            tour_length = calculate_total_distance(best_path, distances)
            print(f"Iteration {iteration}, Best Path Length: {tour_length}")

total_computation_time = time.time() - start_time

print("Best Fitness:", best_fitness)
print("Best Path:", best_path)
print("Total Computation Time:", total_computation_time, "seconds")
print("Average Computation Time per Iteration:", np.mean(computation_times), "seconds")
print("Memory Usage:", memory_usages[-1], "bytes")

# Plotting the best fitness over iterations
plt.figure(figsize=(10, 5))
plt.plot(best_distances, label='Best Fitness')
plt.xlabel('Iteration')
plt.ylabel('Total Distance (Fitness)')
plt.title('Best Fitness over Iterations')
plt.legend()
plt.show()

# Plotting the convergence rate
plt.figure(figsize=(10, 5))
plt.plot(convergence_rates, label='Convergence Rate')
plt.xlabel('Iteration')
plt.ylabel('Fitness')
plt.title('Convergence Rate over Iterations')
plt.legend()
plt.show()

# Plotting computation time per iteration
plt.figure(figsize=(10, 5))
plt.plot(computation_times, label='Computation Time per Iteration')
plt.xlabel('Iteration')
plt.ylabel('Time (seconds)')
plt.title('Computation Time per Iteration')
plt.legend()
plt.show()

# Plotting memory usage over iterations
plt.figure(figsize=(10, 5))
plt.plot(memory_usages, label='Memory Usage per Iteration')
plt.xlabel('Iteration')
plt.ylabel('Memory Usage (bytes)')
plt.title('Memory Usage over Iterations')
plt.legend()
plt.show()

# Plotting solution diversity over iterations
plt.figure(figsize=(10, 5))
plt.plot(all_solutions, label='All Solutions')
plt.xlabel('Iteration')
plt.ylabel('Fitness')
plt.title('Solution Diversity over Iterations')
plt.legend()
plt.show()

"""##v3: 3840"""

import numpy as np
import gzip
import shutil
import matplotlib.pyplot as plt
import time
from python_tsp.exact import solve_tsp_dynamic_programming

# Function to extract .gz file
def extract_gzip(source_filepath, destination_filepath):
    with gzip.open(source_filepath, 'rb') as f_in, open(destination_filepath, 'wb') as f_out:
        shutil.copyfileobj(f_in, f_out)

# Function to load coordinates from the .tsp file
def load_coordinates(file_path):
    coordinates = []
    start_reading = False
    with open(file_path, 'r') as file:
        for line in file:
            if "NODE_COORD_SECTION" in line:
                start_reading = True
            elif "EOF" in line:
                break
            elif start_reading:
                parts = line.strip().split()
                if len(parts) == 3 and parts[0].isdigit():
                    coordinates.append((float(parts[1]), float(parts[2])))
    return coordinates

# Function to calculate geographical distances using the Haversine formula
def haversine(coord1, coord2):
    # Radius of the Earth in km
    R = 6371.0
    lat1, lon1 = np.radians(coord1)
    lat2, lon2 = np.radians(coord2)

    dlat = lat2 - lat1
    dlon = lon2 - lon1

    a = np.sin(dlat / 2)**2 + np.cos(lat1) * np.cos(lat2) * np.sin(dlon / 2)**2
    c = 2 * np.arctan2(np.sqrt(a), np.sqrt(1 - a))
    distance = R * c
    return distance

# Extract and load city coordinates
source_filepath = '/content/burma14.tsp.gz'
destination_filepath = 'burma14.tsp'
extract_gzip(source_filepath, destination_filepath)
cities = np.array(load_coordinates(destination_filepath))
print("Loaded coordinates for", len(cities), "cities.")

# Calculate distance matrix
def calculate_distances(cities):
    num_cities = len(cities)
    distances = np.zeros((num_cities, num_cities))
    for i in range(num_cities):
        for j in range(num_cities):
            if i != j:
                distances[i, j] = haversine(cities[i], cities[j])
            else:
                distances[i, j] = np.inf
    return distances

distances = calculate_distances(cities)
pressures = np.random.rand(len(cities)) * 10
conductivities = np.random.rand(len(cities), len(cities)) * 0.01  # Random initial values

decay_rate = 0.01
k = 0.1
m = 2
epsilon = 1e-10

def calculate_fluxes(pressures, conductivities, distances, epsilon=1e-10):
    num_cities = len(pressures)
    fluxes = np.zeros((num_cities, num_cities))
    for i in range(num_cities):
        for j in range(num_cities):
            if i != j:
                distance = max(distances[i][j], epsilon)  # Avoid division by zero
                delta_p = np.clip(pressures[i] - pressures[j], -1e3, 1e3)
                fluxes[i][j] = (conductivities[i][j] / distance) * delta_p
    return fluxes

def update_conductivities(conductivities, fluxes, decay_rate, m):
    num_cities = len(conductivities)
    for i in range(num_cities):
        for j in range(num_cities):
            if i != j:
                flux = np.clip(abs(fluxes[i][j]), 0, 1e3)  # Control the size of the flux to prevent overflow
                growth = k * (flux ** m) - decay_rate * conductivities[i][j]
                growth = np.clip(growth, -1e2, 1e2)  # Limit the growth to prevent explosive updates
                conductivities[i][j] += growth
    return conductivities

def update_pressures(pressures, fluxes, rate=0.05):
    num_cities = len(pressures)
    for i in range(num_cities):
        net_influx = np.sum(fluxes[:, i]) - np.sum(fluxes[i, :])
        pressures[i] += rate * net_influx
        pressures[i] = np.clip(pressures[i], 0, 1e2)  # Prevent pressure from becoming negative or excessively high
    return pressures

def prune_connections(conductivities, threshold=0.005):
    conductivities[conductivities < threshold] = 0
    return conductivities

# Function to extract a TSP path using python-tsp
def extract_tsp_path(conductivities, distances):
    adjusted_distances = np.where(conductivities > 0, distances, np.inf)
    permutation, distance = solve_tsp_dynamic_programming(adjusted_distances)
    return permutation, distance

# Function to calculate the total distance of a given path
def calculate_total_distance(path, distances):
    total_distance = 0
    for i in range(len(path) - 1):
        if distances[path[i], path[i + 1]] == np.inf:
            print(f"Invalid distance between {path[i]} and {path[i + 1]}")
            return np.inf
        total_distance += distances[path[i], path[i + 1]]
    # Add the distance to return to the starting point
    if distances[path[-1], path[0]] == np.inf:
        print(f"Invalid distance between {path[-1]} and {path[0]}")
        return np.inf
    total_distance += distances[path[-1], path[0]]
    return total_distance

# Function to calculate memory usage
def calculate_memory_usage(conductivities):
    return conductivities.nbytes

# Simulation loop with best solution tracking and additional performance measures
num_iterations = 50
best_fitness = np.inf
best_path = None
best_distances = []
computation_times = []
convergence_rates = []
memory_usages = []
all_solutions = []

start_time = time.time()

for iteration in range(num_iterations):
    iteration_start_time = time.time()

    fluxes = calculate_fluxes(pressures, conductivities, distances)
    pressures = update_pressures(pressures, fluxes)
    conductivities = update_conductivities(conductivities, fluxes, decay_rate, m)

    iteration_end_time = time.time()
    computation_times.append(iteration_end_time - iteration_start_time)

    if iteration % 5 == 0:  # Periodically prune and check for best solution
        conductivities = prune_connections(conductivities)
        current_path, current_fitness = extract_tsp_path(conductivities, distances)
        print(f"Iteration {iteration}, Current Path: {current_path}, Current Fitness: {current_fitness}")
        all_solutions.append(current_fitness)

        if current_fitness < best_fitness:
            best_fitness = current_fitness
            best_path = current_path

        best_distances.append(best_fitness)
        convergence_rates.append(best_fitness)
        memory_usages.append(calculate_memory_usage(conductivities))

        # Print the length of the tour for the current best path
        if best_path is not None:
            tour_length = calculate_total_distance(best_path, distances)
            print(f"Iteration {iteration}, Best Path Length: {tour_length}")

total_computation_time = time.time() - start_time

print("Best Fitness:", best_fitness)
print("Best Path:", best_path)
print("Total Computation Time:", total_computation_time, "seconds")
print("Average Computation Time per Iteration:", np.mean(computation_times), "seconds")
print("Memory Usage:", memory_usages[-1], "bytes")

# Plotting the best fitness over iterations
plt.figure(figsize=(10, 5))
plt.plot(best_distances, label='Best Fitness')
plt.xlabel('Iteration')
plt.ylabel('Total Distance (Fitness)')
plt.title('Best Fitness over Iterations')
plt.legend()
plt.show()

# Plotting the convergence rate
plt.figure(figsize=(10, 5))
plt.plot(convergence_rates, label='Convergence Rate')
plt.xlabel('Iteration')
plt.ylabel('Fitness')
plt.title('Convergence Rate over Iterations')
plt.legend()
plt.show()

# Plotting computation time per iteration
plt.figure(figsize=(10, 5))
plt.plot(computation_times, label='Computation Time')
plt.xlabel('Iteration')
plt.ylabel('Time (seconds)')
plt.title('Computation Time per Iteration')
plt.legend()
plt.show()

# Plotting memory usage over iterations
plt.figure(figsize=(10, 5))
plt.plot(memory_usages, label='Memory Usage')
plt.xlabel('Iteration')
plt.ylabel('Memory Usage (bytes)')
plt.title('Memory Usage over Iterations')
plt.legend()
plt.show()

"""##v4 : 4360"""

import numpy as np
import gzip
import shutil
import matplotlib.pyplot as plt
import time
from python_tsp.exact import solve_tsp_dynamic_programming

# Function to extract .gz file
def extract_gzip(source_filepath, destination_filepath):
    with gzip.open(source_filepath, 'rb') as f_in, open(destination_filepath, 'wb') as f_out:
        shutil.copyfileobj(f_in, f_out)

# Function to load coordinates from the .tsp file
def load_coordinates(file_path):
    coordinates = []
    start_reading = False
    with open(file_path, 'r') as file:
        for line in file:
            if "NODE_COORD_SECTION" in line:
                start_reading = True
            elif "EOF" in line:
                break
            elif start_reading:
                parts = line.strip().split()
                if len(parts) == 3 and parts[0].isdigit():
                    coordinates.append((float(parts[1]), float(parts[2])))
    return coordinates

# Function to calculate geographical distances using the Haversine formula
def haversine(coord1, coord2):
    # Radius of the Earth in km
    R = 6371.0
    lat1, lon1 = np.radians(coord1)
    lat2, lon2 = np.radians(coord2)

    dlat = lat2 - lat1
    dlon = lon2 - lon1

    a = np.sin(dlat / 2)**2 + np.cos(lat1) * np.cos(lat2) * np.sin(dlon / 2)**2
    c = 2 * np.arctan2(np.sqrt(a), np.sqrt(1 - a))
    distance = R * c
    return distance

# Extract and load city coordinates
source_filepath = '/content/burma14.tsp.gz'
destination_filepath = 'burma14.tsp'
extract_gzip(source_filepath, destination_filepath)
cities = np.array(load_coordinates(destination_filepath))
print("Loaded coordinates for", len(cities), "cities.")

# Calculate distance matrix
def calculate_distances(cities):
    num_cities = len(cities)
    distances = np.zeros((num_cities, num_cities))
    for i in range(num_cities):
        for j in range(num_cities):
            if i != j:
                distances[i, j] = haversine(cities[i], cities[j])
            else:
                distances[i, j] = np.inf
    return distances

distances = calculate_distances(cities)
pressures = np.random.rand(len(cities)) * 10
conductivities = np.random.rand(len(cities), len(cities)) * 0.01  # Random initial values

decay_rate = 0.01
m = 2
epsilon = 1e-10

def calculate_fluxes(pressures, conductivities, distances, epsilon=1e-10):
    num_cities = len(pressures)
    fluxes = np.zeros((num_cities, num_cities))
    for i in range(num_cities):
        for j in range(num_cities):
            if i != j:
                distance = max(distances[i][j], epsilon)  # Avoid division by zero
                delta_p = np.clip(pressures[i] - pressures[j], -1e3, 1e3)
                fluxes[i][j] = (conductivities[i][j] / distance) * delta_p
    return fluxes

def update_conductivities(conductivities, fluxes, decay_rate):
    num_cities = len(conductivities)
    for i in range(num_cities):
        for j in range(num_cities):
            if i != j:
                flux = np.clip(abs(fluxes[i][j]), 0, 1e3)  # Control the size of the flux to prevent overflow
                growth = (flux ** 2) - decay_rate * conductivities[i][j]
                growth = np.clip(growth, -1e2, 1e2)  # Limit the growth to prevent explosive updates
                conductivities[i][j] += growth
    return conductivities

def update_pressures(pressures, fluxes, rate=0.05):
    num_cities = len(pressures)
    for i in range(num_cities):
        net_influx = np.sum(fluxes[:, i]) - np.sum(fluxes[i, :])
        pressures[i] += rate * net_influx
        pressures[i] = np.clip(pressures[i], 0, 1e2)  # Prevent pressure from becoming negative or excessively high
    return pressures

def prune_connections(conductivities, threshold=0.005):
    conductivities[conductivities < threshold] = 0
    return conductivities

# Function to extract a TSP path using python-tsp
def extract_tsp_path(conductivities, distances):
    adjusted_distances = np.where(conductivities > 0, distances, np.inf)
    permutation, distance = solve_tsp_dynamic_programming(adjusted_distances)
    return permutation, distance

# Function to calculate the total distance of a given path
def calculate_total_distance(path, distances):
    total_distance = 0
    for i in range(len(path) - 1):
        if distances[path[i], path[i + 1]] == np.inf:
            print(f"Invalid distance between {path[i]} and {path[i + 1]}")
            return np.inf
        total_distance += distances[path[i], path[i + 1]]
    # Add the distance to return to the starting point
    if distances[path[-1], path[0]] == np.inf:
        print(f"Invalid distance between {path[-1]} and {path[0]}")
        return np.inf
    total_distance += distances[path[-1], path[0]]
    return total_distance

# Function to calculate memory usage
def calculate_memory_usage(conductivities):
    return conductivities.nbytes

# Simulation loop with best solution tracking and additional performance measures
num_iterations = 50
best_fitness = np.inf
best_path = None
best_distances = []
computation_times = []
convergence_rates = []
memory_usages = []
all_solutions = []

start_time = time.time()

for iteration in range(num_iterations):
    iteration_start_time = time.time()

    fluxes = calculate_fluxes(pressures, conductivities, distances)
    pressures = update_pressures(pressures, fluxes)
    conductivities = update_conductivities(conductivities, fluxes, decay_rate)

    iteration_end_time = time.time()
    computation_times.append(iteration_end_time - iteration_start_time)

    if iteration % 5 == 0:  # Periodically prune and check for best solution
        conductivities = prune_connections(conductivities)
        current_path, current_fitness = extract_tsp_path(conductivities, distances)
        print(f"Iteration {iteration}, Current Path: {current_path}, Current Fitness: {current_fitness}")
        all_solutions.append(current_fitness)

        if current_fitness < best_fitness:
            best_fitness = current_fitness
            best_path = current_path

        best_distances.append(best_fitness)
        convergence_rates.append(best_fitness)
        memory_usages.append(calculate_memory_usage(conductivities))

        # Print the length of the tour for the current best path
        if best_path is not None:
            tour_length = calculate_total_distance(best_path, distances)
            print(f"Iteration {iteration}, Best Path Length: {tour_length}")

total_computation_time = time.time() - start_time

print("Best Fitness:", best_fitness)
print("Best Path:", best_path)
print("Total Computation Time:", total_computation_time, "seconds")
print("Average Computation Time per Iteration:", np.mean(computation_times), "seconds")
print("Memory Usage:", memory_usages[-1], "bytes")

# Plotting the best fitness over iterations
plt.figure(figsize=(10, 5))
plt.plot(best_distances, label='Best Fitness')
plt.xlabel('Iteration')
plt.ylabel('Total Distance (Fitness)')
plt.title('Best Fitness over Iterations')
plt.legend()
plt.show()

# Plotting the convergence rate
plt.figure(figsize=(10, 5))
plt.plot(convergence_rates, label='Convergence Rate')
plt.xlabel('Iteration')
plt.ylabel('Fitness')
plt.title('Convergence Rate over Iterations')
plt.legend()
plt.show()

# Plotting computation time per iteration
plt.figure(figsize=(10, 5))
plt.plot(computation_times, label='Computation Time')
plt.xlabel('Iteration')
plt.ylabel('Time (seconds)')
plt.title('Computation Time per Iteration')
plt.legend()
plt.show()

# Plotting memory usage over iterations
plt.figure(figsize=(10, 5))
plt.plot(memory_usages, label='Memory Usage')
plt.xlabel('Iteration')
plt.ylabel('Memory Usage (bytes)')
plt.title('Memory Usage over Iterations')
plt.legend()
plt.show()

"""##v5: 4061"""

import numpy as np
import gzip
import shutil
import matplotlib.pyplot as plt
import time
from python_tsp.exact import solve_tsp_dynamic_programming

# Function to extract .gz file
def extract_gzip(source_filepath, destination_filepath):
    with gzip.open(source_filepath, 'rb') as f_in, open(destination_filepath, 'wb') as f_out:
        shutil.copyfileobj(f_in, f_out)

# Function to load coordinates from the .tsp file
def load_coordinates(file_path):
    coordinates = []
    start_reading = False
    with open(file_path, 'r') as file:
        for line in file:
            if "NODE_COORD_SECTION" in line:
                start_reading = True
            elif "EOF" in line:
                break
            elif start_reading:
                parts = line.strip().split()
                if len(parts) == 3 and parts[0].isdigit():
                    coordinates.append((float(parts[1]), float(parts[2])))
    return coordinates

# Function to calculate geographical distances using the Haversine formula
def haversine(coord1, coord2):
    # Radius of the Earth in km
    R = 6371.0
    lat1, lon1 = np.radians(coord1)
    lat2, lon2 = np.radians(coord2)

    dlat = lat2 - lat1
    dlon = lon2 - lon1

    a = np.sin(dlat / 2)**2 + np.cos(lat1) * np.cos(lat2) * np.sin(dlon / 2)**2
    c = 2 * np.arctan2(np.sqrt(a), np.sqrt(1 - a))
    distance = R * c
    return distance

# Extract and load city coordinates
source_filepath = '/content/burma14.tsp.gz'
destination_filepath = 'burma14.tsp'
extract_gzip(source_filepath, destination_filepath)
cities = np.array(load_coordinates(destination_filepath))
print("Loaded coordinates for", len(cities), "cities.")

# Calculate distance matrix
def calculate_distances(cities):
    num_cities = len(cities)
    distances = np.zeros((num_cities, num_cities))
    for i in range(num_cities):
        for j in range(num_cities):
            if i != j:
                distances[i, j] = haversine(cities[i], cities[j])
            else:
                distances[i, j] = np.inf
    return distances

distances = calculate_distances(cities)

# Initialize pressures and conductivities
np.random.seed(42)  # For reproducibility
pressures = np.random.rand(len(cities)) * 10
conductivities = np.random.rand(len(cities), len(cities)) * 0.01

decay_rate = 0.01
epsilon = 1e-10

def calculate_fluxes(pressures, conductivities, distances, epsilon=1e-10):
    num_cities = len(pressures)
    fluxes = np.zeros((num_cities, num_cities))
    for i in range(num_cities):
        for j in range(num_cities):
            if i != j:
                distance = max(distances[i][j], epsilon)  # Avoid division by zero
                delta_p = np.clip(pressures[i] - pressures[j], -1e3, 1e3)
                fluxes[i][j] = (conductivities[i][j] / distance) * delta_p
    return fluxes

def update_conductivities(conductivities, fluxes, decay_rate):
    num_cities = len(conductivities)
    for i in range(num_cities):
        for j in range(num_cities):
            if i != j:
                flux = np.clip(abs(fluxes[i][j]), 0, 1e3)
                growth = (flux ** 2) - decay_rate * conductivities[i][j]
                growth = np.clip(growth, -1e2, 1e2)
                conductivities[i][j] += growth
    return conductivities

def update_pressures(pressures, fluxes, rate=0.05):
    num_cities = len(pressures)
    for i in range(num_cities):
        net_influx = np.sum(fluxes[:, i]) - np.sum(fluxes[i, :])
        pressures[i] += rate * net_influx
        pressures[i] = np.clip(pressures[i], 0, 1e2)
    return pressures

def prune_connections(conductivities, threshold=0.005):
    conductivities[conductivities < threshold] = 0
    return conductivities

# Function to extract a TSP path using python-tsp
def extract_tsp_path(conductivities, distances):
    adjusted_distances = np.where(conductivities > 0, distances, np.inf)
    permutation, distance = solve_tsp_dynamic_programming(adjusted_distances)
    return permutation, distance

# Function to calculate the total distance of a given path
def calculate_total_distance(path, distances):
    total_distance = 0
    for i in range(len(path) - 1):
        if distances[path[i], path[i + 1]] == np.inf:
            print(f"Invalid distance between {path[i]} and {path[i + 1]}")
            return np.inf
        total_distance += distances[path[i], path[i + 1]]
    # Add the distance to return to the starting point
    if distances[path[-1], path[0]] == np.inf:
        print(f"Invalid distance between {path[-1]} and {path[0]}")
        return np.inf
    total_distance += distances[path[-1], path[0]]
    return total_distance

# Function to calculate memory usage
def calculate_memory_usage(conductivities):
    return conductivities.nbytes

# Simulation loop with best solution tracking and additional performance measures
num_iterations = 50
best_fitness = np.inf
best_path = None
best_distances = []
computation_times = []
convergence_rates = []
memory_usages = []
all_solutions = []

start_time = time.time()

for iteration in range(num_iterations):
    iteration_start_time = time.time()

    fluxes = calculate_fluxes(pressures, conductivities, distances)
    pressures = update_pressures(pressures, fluxes)
    conductivities = update_conductivities(conductivities, fluxes, decay_rate)

    iteration_end_time = time.time()
    computation_times.append(iteration_end_time - iteration_start_time)

    if iteration % 5 == 0:  # Periodically prune and check for best solution
        conductivities = prune_connections(conductivities)
        current_path, current_fitness = extract_tsp_path(conductivities, distances)
        print(f"Iteration {iteration}, Current Path: {current_path}, Current Fitness: {current_fitness}")
        all_solutions.append(current_fitness)

        if current_fitness < best_fitness:
            best_fitness = current_fitness
            best_path = current_path

        best_distances.append(best_fitness)
        convergence_rates.append(best_fitness)
        memory_usages.append(calculate_memory_usage(conductivities))

        # Print the length of the tour for the current best path
        if best_path is not None:
            tour_length = calculate_total_distance(best_path, distances)
            print(f"Iteration {iteration}, Best Path Length: {tour_length}")

total_computation_time = time.time() - start_time

print("Best Fitness:", best_fitness)
print("Best Path:", best_path)
print("Total Computation Time:", total_computation_time, "seconds")
print("Average Computation Time per Iteration:", np.mean(computation_times), "seconds")
print("Memory Usage:", memory_usages[-1], "bytes")

# Plotting the best fitness over iterations
plt.figure(figsize=(10, 5))
plt.plot(best_distances, label='Best Fitness')
plt.xlabel('Iteration')
plt.ylabel('Total Distance (Fitness)')
plt.title('Best Fitness over Iterations')
plt.legend()
plt.show()

# Plotting the convergence rate
plt.figure(figsize=(10, 5))
plt.plot(convergence_rates, label='Convergence Rate')
plt.xlabel('Iteration')
plt.ylabel('Fitness')
plt.title('Convergence Rate over Iterations')
plt.legend()
plt.show()

# Plotting computation time per iteration
plt.figure(figsize=(10, 5))
plt.plot(computation_times, label='Computation Time')
plt.xlabel('Iteration')
plt.ylabel('Time (seconds)')
plt.title('Computation Time per Iteration')
plt.legend()
plt.show()

# Plotting memory usage over iterations
plt.figure(figsize=(10, 5))
plt.plot(memory_usages, label='Memory Usage')
plt.xlabel('Iteration')
plt.ylabel('Memory Usage (bytes)')
plt.title('Memory Usage over Iterations')
plt.legend()
plt.show()

import numpy as np
import gzip
import shutil
import matplotlib.pyplot as plt
import time
from python_tsp.exact import solve_tsp_dynamic_programming

# Function to extract .gz file
def extract_gzip(source_filepath, destination_filepath):
    with gzip.open(source_filepath, 'rb') as f_in, open(destination_filepath, 'wb') as f_out:
        shutil.copyfileobj(f_in, f_out)

# Function to load coordinates from the .tsp file
def load_coordinates(file_path):
    coordinates = []
    start_reading = False
    with open(file_path, 'r') as file:
        for line in file:
            if "NODE_COORD_SECTION" in line:
                start_reading = True
            elif "EOF" in line:
                break
            elif start_reading:
                parts = line.strip().split()
                if len(parts) == 3 and parts[0].isdigit():
                    coordinates.append((float(parts[1]), float(parts[2])))
    return coordinates

# Function to calculate geographical distances using the Haversine formula
def haversine(coord1, coord2):
    R = 6371.0  # Radius of the Earth in km
    lat1, lon1 = np.radians(coord1)
    lat2, lon2 = np.radians(coord2)

    dlat = lat2 - lat1
    dlon = lon2 - lon1

    a = np.sin(dlat / 2)**2 + np.cos(lat1) * np.cos(lat2) * np.sin(dlon / 2)**2
    c = 2 * np.arctan2(np.sqrt(a), np.sqrt(1 - a))
    distance = R * c
    return distance

# Extract and load city coordinates
source_filepath = 'burma14.tsp.gz'
destination_filepath = 'burma14.tsp'
extract_gzip(source_filepath, destination_filepath)
cities = np.array(load_coordinates(destination_filepath))
print("Loaded coordinates for", len(cities), "cities.")

# Calculate distance matrix
def calculate_distances(cities):
    num_cities = len(cities)
    distances = np.zeros((num_cities, num_cities))
    for i in range(num_cities):
        for j in range(num_cities):
            if i != j:
                distances[i, j] = haversine(cities[i], cities[j])
            else:
                distances[i, j] = np.inf
    return distances

distances = calculate_distances(cities)

# Initialize pressures and conductivities
np.random.seed(42)  # For reproducibility
pressures = np.random.rand(len(cities)) * 10
conductivities = np.random.rand(len(cities), len(cities)) * 0.01

decay_rate = 0.01
epsilon = 1e-10

def calculate_fluxes(pressures, conductivities, distances, epsilon=1e-10):
    num_cities = len(pressures)
    fluxes = np.zeros((num_cities, num_cities))
    for i in range(num_cities):
        for j in range(num_cities):
            if i != j:
                distance = max(distances[i][j], epsilon)  # Avoid division by zero
                delta_p = pressures[i] - pressures[j]
                fluxes[i][j] = (conductivities[i][j] / distance) * delta_p
    return fluxes

def update_conductivities(conductivities, fluxes, decay_rate):
    num_cities = len(conductivities)
    for i in range(num_cities):
        for j in range(num_cities):
            if i != j:
                flux = abs(fluxes[i][j])
                growth = (flux ** 2) - decay_rate * conductivities[i][j]
                conductivities[i][j] += growth
                if conductivities[i][j] < 0:
                    conductivities[i][j] = 0  # Ensure non-negative conductivities
    return conductivities

def update_pressures(pressures, fluxes):
    num_cities = len(pressures)
    for i in range(num_cities):
        net_flux = np.sum(fluxes[:, i]) - np.sum(fluxes[i, :])
        pressures[i] += net_flux
        pressures[i] = np.clip(pressures[i], 0, 100)  # Ensure pressures remain within bounds
    return pressures

def prune_connections(conductivities, threshold=0.005):
    conductivities[conductivities < threshold] = 0
    return conductivities

# Function to extract a TSP path using python-tsp
def extract_tsp_path(conductivities, distances):
    adjusted_distances = np.where(conductivities > 0, distances, np.inf)
    permutation, distance = solve_tsp_dynamic_programming(adjusted_distances)
    return permutation, distance

# Function to calculate the total distance of a given path
def calculate_total_distance(path, distances):
    total_distance = 0
    for i in range(len(path) - 1):
        if distances[path[i], path[i + 1]] == np.inf:
            print(f"Invalid distance between {path[i]} and {path[i + 1]}")
            return np.inf
        total_distance += distances[path[i], path[i + 1]]
    # Add the distance to return to the starting point
    if distances[path[-1], path[0]] == np.inf:
        print(f"Invalid distance between {path[-1]} and {path[0]}")
        return np.inf
    total_distance += distances[path[-1], path[0]]
    return total_distance

# Function to calculate memory usage
def calculate_memory_usage(conductivities):
    return conductivities.nbytes

# Simulation loop with best solution tracking and additional performance measures
num_iterations = 50
best_fitness = np.inf
best_path = None
best_distances = []
computation_times = []
convergence_rates = []
memory_usages = []
all_solutions = []

start_time = time.time()

for iteration in range(num_iterations):
    iteration_start_time = time.time()

    fluxes = calculate_fluxes(pressures, conductivities, distances)
    pressures = update_pressures(pressures, fluxes)
    conductivities = update_conductivities(conductivities, fluxes, decay_rate)

    iteration_end_time = time.time()
    computation_times.append(iteration_end_time - iteration_start_time)

    if iteration % 5 == 0:  # Periodically prune and check for best solution
        conductivities = prune_connections(conductivities)
        current_path, current_fitness = extract_tsp_path(conductivities, distances)
        print(f"Iteration {iteration}, Current Path: {current_path}, Current Fitness: {current_fitness}")
        all_solutions.append(current_fitness)

        if current_fitness < best_fitness:
            best_fitness = current_fitness
            best_path = current_path

        best_distances.append(best_fitness)
        convergence_rates.append(best_fitness)
        memory_usages.append(calculate_memory_usage(conductivities))

        # Print the length of the tour for the current best path
        if best_path is not None:
            tour_length = calculate_total_distance(best_path, distances)
            print(f"Iteration {iteration}, Best Path Length: {tour_length}")

total_computation_time = time.time() - start_time

print("Best Fitness:", best_fitness)
print("Best Path:", best_path)
print("Total Computation Time:", total_computation_time, "seconds")
print("Average Computation Time per Iteration:", np.mean(computation_times), "seconds")
print("Memory Usage:", memory_usages[-1], "bytes")

# Plotting the best fitness over iterations
plt.figure(figsize=(10, 5))
plt.plot(best_distances, label='Best Fitness')
plt.xlabel('Iteration')
plt.ylabel('Total Distance (Fitness)')
plt.title('Best Fitness over Iterations')
plt.legend()
plt.show()

# Plotting the convergence rate
plt.figure(figsize=(10, 5))
plt.plot(convergence_rates, label='Convergence Rate')
plt.xlabel('Iteration')
plt.ylabel('Fitness')
plt.title('Convergence Rate over Iterations')
plt.legend()
plt.show()

# Plotting computation time per iteration
plt.figure(figsize=(10, 5))
plt.plot(computation_times, label='Computation Time')
plt.xlabel('Iteration')
plt.ylabel('Time (seconds)')
plt.title('Computation Time per Iteration')
plt.legend()
plt.show()

# Plotting memory usage over iterations
plt.figure(figsize=(10, 5))
plt.plot(memory_usages, label='Memory Usage')
plt.xlabel('Iteration')
plt.ylabel('Memory Usage (bytes)')
plt.title('Memory Usage over Iterations')
plt.legend()
plt.show()

"""##Final Version

###burma optimal solution 3323, achieved 3354 -  the best i could do.
"""

!pip install python_tsp

import numpy as np
import gzip
import shutil
import matplotlib.pyplot as plt
import time
from python_tsp.exact import solve_tsp_dynamic_programming

# Function to extract .gz file
def extract_gzip(source_filepath, destination_filepath):
    with gzip.open(source_filepath, 'rb') as f_in, open(destination_filepath, 'wb') as f_out:
        shutil.copyfileobj(f_in, f_out)

# Function to load coordinates from the .tsp file
def load_coordinates(file_path):
    coordinates = []
    start_reading = False
    with open(file_path, 'r') as file:
        for line in file:
            if "NODE_COORD_SECTION" in line:
                start_reading = True
            elif "EOF" in line:
                break
            elif start_reading:
                parts = line.strip().split()
                if len(parts) == 3 and parts[0].isdigit():
                    coordinates.append((float(parts[1]), float(parts[2])))
    return coordinates

# Function to calculate geographical distances using the Haversine formula
def haversine(coord1, coord2):
    R = 6371.0  # Radius of the Earth in km
    lat1, lon1 = np.radians(coord1)
    lat2, lon2 = np.radians(coord2)
    dlat = lat2 - lat1
    dlon = lon2 - lon1
    a = np.sin(dlat / 2)**2 + np.cos(lat1) * np.cos(lat2) * np.sin(dlon / 2)**2
    c = 2 * np.arctan2(np.sqrt(a), np.sqrt(1 - a))
    distance = R * c
    return distance

# Extract and load city coordinates
source_filepath = '/content/burma14.tsp.gz'
destination_filepath = 'burma14.tsp'
extract_gzip(source_filepath, destination_filepath)
cities = np.array(load_coordinates(destination_filepath))
print("Loaded coordinates for", len(cities), "cities.")

# Calculate distance matrix
def calculate_distances(cities):
    num_cities = len(cities)
    distances = np.zeros((num_cities, num_cities))
    for i in range(num_cities):
        for j in range(num_cities):
            if i != j:
                distances[i, j] = haversine(cities[i], cities[j])
            else:
                distances[i, j] = np.inf
    return distances

distances = calculate_distances(cities)
print("Distance matrix:")
print(distances)

# Initialize pressures and conductivities
pressures = np.random.rand(len(cities)) * 10
conductivities = np.ones_like(distances) * 0.01  # Initial small value for all conductivities

decay_rate = 0.1
k = 0.1
m = 2
epsilon = 1e-10

# Function to calculate fluxes
def calculate_fluxes(pressures, conductivities, distances, epsilon=1e-10):
    num_cities = len(pressures)
    fluxes = np.zeros((num_cities, num_cities))
    for i in range(num_cities):
        for j in range(num_cities):
            if i != j:
                distance = max(distances[i][j], epsilon)  # Avoid division by zero
                delta_p = np.clip(pressures[i] - pressures[j], -1e3, 1e3)  # Ensure pressures do not cause overflow
                fluxes[i][j] = (conductivities[i][j] / distance) * delta_p
    return fluxes

# Function to update conductivities
def update_conductivities(conductivities, fluxes, decay_rate, k, m):
    num_cities = len(conductivities)
    for i in range(num_cities):
        for j in range(num_cities):
            if i != j:
                flux = np.clip(abs(fluxes[i][j]), 0, 1e3)  # Control the size of the flux to prevent overflow
                growth = k * (flux ** m) - decay_rate * conductivities[i][j]
                growth = np.clip(growth, -1e2, 1e2)  # Limit the growth to prevent explosive updates
                conductivities[i][j] += growth + np.random.rand() * 0.001  # Add randomness to explore more paths
    return conductivities

# Function to update pressures
def update_pressures(pressures, fluxes, rate=0.05):
    num_cities = len(pressures)
    for i in range(num_cities):
        net_influx = np.sum(fluxes[:, i]) - np.sum(fluxes[i, :])
        pressures[i] += rate * net_influx
        pressures[i] = np.clip(pressures[i], 0, 1e2)  # Prevent pressure from becoming negative or excessively high
    return pressures

# Function to prune connections
def prune_connections(conductivities, threshold=0.005):
    conductivities[conductivities < threshold] = 0
    return conductivities

# Function to extract a TSP path using python-tsp
def extract_tsp_path(conductivities, distances):
    adjusted_distances = np.where(conductivities > 0, distances, np.inf)
    permutation, distance = solve_tsp_dynamic_programming(adjusted_distances)
    return permutation, distance

# Function to calculate the total distance of a given path
def calculate_total_distance(path, distances):
    total_distance = 0
    for i in range(len(path) - 1):
        if distances[path[i], path[i + 1]] == np.inf:
            print(f"Invalid distance between {path[i]} and {path[i + 1]}")
            return np.inf
        total_distance += distances[path[i], path[i + 1]]
    # Add the distance to return to the starting point
    if distances[path[-1], path[0]] == np.inf:
        print(f"Invalid distance between {path[-1]} and {path[0]}")
        return np.inf
    total_distance += distances[path[-1], path[0]]
    return total_distance

# Function to calculate memory usage
def calculate_memory_usage(conductivities):
    return conductivities.nbytes

# Function to plot the best path
def plot_best_path(best_path, cities):
    path_coords = cities[best_path]
    plt.figure(figsize=(10, 6))
    plt.plot(path_coords[:, 0], path_coords[:, 1], 'o-', markersize=10)
    plt.plot([path_coords[-1, 0], path_coords[0, 0]], [path_coords[-1, 1], path_coords[0, 1]], 'o-', markersize=10)  # Connect last to first
    for i, coord in enumerate(path_coords):
        plt.annotate(str(i + 1), (coord[0], coord[1]))
    plt.title("Best Path")
    plt.xlabel("X Coordinate")
    plt.ylabel("Y Coordinate")
    plt.grid(True)
    plt.show()

# Function to plot the fitness over iterations
def plot_fitness_over_iterations(all_fitness):
    plt.figure(figsize=(10, 6))
    plt.plot(all_fitness, 'o-', markersize=5)
    plt.title("Fitness over Iterations")
    plt.xlabel("Iteration")
    plt.ylabel("Total Distance (Fitness)")
    plt.grid(True)
    plt.show()

# Simulation loop
num_iterations = 50
best_fitness = np.inf
best_path = None
best_distances = []
computation_times = []
convergence_rates = []
memory_usages = []
all_solutions = []
all_paths = []

start_time = time.time()

for iteration in range(num_iterations):
    iteration_start_time = time.time()

    # Calculate fluxes based on current pressures and conductivities.
    #NB This step simulates the nutrient flow in slime mold.
    fluxes = calculate_fluxes(pressures, conductivities, distances)

    # Update pressures based on the calculated fluxes.
    #NB This step simulates the adaptation of pressure levels in slime mold.
    pressures = update_pressures(pressures, fluxes)

    # Update conductivities based on the fluxes.
    #NB Paths with higher fluxes get increased conductivities, mimicking slime mold's path reinforcement.
    conductivities = update_conductivities(conductivities, fluxes, decay_rate, k, m)

    iteration_end_time = time.time()
    computation_times.append(iteration_end_time - iteration_start_time)

    # Prune connections with low conductivities to remove inefficient paths.
    #NB This step simulates the pruning of less efficient paths by slime mold.
    conductivities = prune_connections(conductivities)

    # Extract the TSP path using the adjusted distance matrix.
    # The conductivities influenced by the slime mold model adjust the distances,
    # setting paths with zero conductivity to infinite distance.
    current_path, current_fitness = extract_tsp_path(conductivities, distances)
    all_paths.append(current_path)
    all_solutions.append(current_fitness)

    # Update the best path and fitness if the current fitness is better.
    if current_fitness < best_fitness:
        best_fitness = current_fitness
        best_path = current_path

    best_distances.append(best_fitness)
    convergence_rates.append(best_fitness)
    memory_usages.append(calculate_memory_usage(conductivities))

    # Print the length of the tour for the current best path
    if best_path is not None:
        tour_length = calculate_total_distance(best_path, distances)
        print(f"Iteration {iteration}, Best Path Length: {tour_length}")

total_computation_time = time.time() - start_time

print("Best Fitness:", best_fitness)
print("Best Path:", best_path)
print("Total Computation Time:", total_computation_time, "seconds")
print("Average Computation Time per Iteration:", np.mean(computation_times), "seconds")
print("Memory Usage:", memory_usages[-1], "bytes")

# Plot the fitness (total distance) over iterations to visualize the convergence.
plot_fitness_over_iterations(all_solutions)

# Plot the best path found during the iterations.
plot_best_path(best_path, cities)

"""#### Animation"""

import numpy as np
import gzip
import shutil
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import time
from python_tsp.exact import solve_tsp_dynamic_programming


# Extract and load city coordinates
source_filepath = '/content/burma14.tsp.gz'
destination_filepath = 'burma14.tsp'
extract_gzip(source_filepath, destination_filepath)
cities = np.array(load_coordinates(destination_filepath))

# Calculate distance matrix
distances = calculate_distances(cities)

# Initialize pressures and conductivities
pressures = np.random.rand(len(cities)) * 10
conductivities = np.ones_like(distances) * 0.01  # Initial small value for all conductivities

decay_rate = 0.01  # Reduced decay rate
k = 0.05  # Reduced growth rate
m = 2

num_iterations = 50
best_fitness = np.inf
best_path = None
all_paths = []
all_solutions = []

fig, ax = plt.subplots()

def update(frame):
    global pressures, conductivities, best_fitness, best_path

    fluxes = calculate_fluxes(pressures, conductivities, distances)
    pressures = update_pressures(pressures, fluxes, rate=0.01)  # More controlled pressure update
    conductivities = update_conductivities(conductivities, fluxes, decay_rate, k, m)

    # Gradual pruning
    threshold = 0.001 + (0.004 * (num_iterations - frame) / num_iterations)
    conductivities = prune_connections(conductivities, threshold=threshold)

    current_path, current_fitness = extract_tsp_path(conductivities, distances)

    if current_fitness < best_fitness:
        best_fitness = current_fitness
        best_path = current_path

    all_paths.append(current_path)
    all_solutions.append(current_fitness)

    # Clear the plot
    ax.clear()

    # Plot the cities
    ax.plot(cities[:, 0], cities[:, 1], 'o')

    # Plot the paths with conductivities
    for i in range(len(cities)):
        for j in range(len(cities)):
            if conductivities[i, j] > 0:
                ax.plot([cities[i, 0], cities[j, 0]], [cities[i, 1], cities[j, 1]], 'b-', alpha=conductivities[i, j])

    # Plot the best path
    if best_path is not None:
        path_coords = cities[best_path]
        ax.plot(path_coords[:, 0], path_coords[:, 1], 'r-', linewidth=2)
        ax.plot([path_coords[-1, 0], path_coords[0, 0]], [path_coords[-1, 1], path_coords[0, 1]], 'r-', linewidth=2)

    ax.set_title(f"Iteration {frame + 1}, Best Path Length: {best_fitness:.2f}")
    ax.set_xlabel("X Coordinate")
    ax.set_ylabel("Y Coordinate")
    ax.grid(True)

# Create the animation
ani = animation.FuncAnimation(fig, update, frames=num_iterations, repeat=False)

# Save the animation if needed
ani.save('slime_mold_tsp_animation_burma_dynamicprogramming.mp4', writer='ffmpeg')

"""###ali535 optimal solution 202339, achieved 227293 -  uses same code as final for burma14"""

!pip install python_tsp

import numpy as np
import matplotlib.pyplot as plt
import time
from python_tsp.exact import solve_tsp_dynamic_programming #changed to simulated annealing
import sys
sys.setrecursionlimit(10000)

# Function to load coordinates from the .tsp file
def load_coordinates(file_path):
    coordinates = []
    start_reading = False
    with open(file_path, 'r') as file:
        for line in file:
            if "NODE_COORD_SECTION" in line:
                start_reading = True
            elif "EOF" in line:
                break
            elif start_reading:
                parts = line.strip().split()
                if len(parts) == 3 and parts[0].isdigit():
                    coordinates.append((float(parts[1]), float(parts[2])))
    return coordinates

# Function to calculate geographical distances using the Haversine formula
def haversine(coord1, coord2):
    R = 6371.0  # Radius of the Earth in km
    lat1, lon1 = np.radians(coord1)
    lat2, lon2 = np.radians(coord2)
    dlat = lat2 - lat1
    dlon = lon2 - lon1
    a = np.sin(dlat / 2)**2 + np.cos(lat1) * np.cos(lat2) * np.sin(dlon / 2)**2
    c = 2 * np.arctan2(np.sqrt(a), np.sqrt(1 - a))
    distance = R * c
    return distance

# Load city coordinates
file_path = '/content/ali535.tsp'
cities = np.array(load_coordinates(file_path))
print("Loaded coordinates for", len(cities), "cities.")

# Calculate distance matrix
def calculate_distances(cities):
    num_cities = len(cities)
    distances = np.zeros((num_cities, num_cities))
    for i in range(num_cities):
        for j in range(num_cities):
            if i != j:
                distances[i, j] = haversine(cities[i], cities[j])
            else:
                distances[i, j] = np.inf
    return distances

distances = calculate_distances(cities)
print("Distance matrix:")
print(distances)

# Initialize pressures and conductivities
pressures = np.random.rand(len(cities)) * 10
conductivities = np.ones_like(distances) * 0.01  # Initial small value for all conductivities

decay_rate = 0.1
k = 0.1
m = 2
epsilon = 1e-10

# Function to calculate fluxes
def calculate_fluxes(pressures, conductivities, distances, epsilon=1e-10):
    num_cities = len(pressures)
    fluxes = np.zeros((num_cities, num_cities))
    for i in range(num_cities):
        for j in range(num_cities):
            if i != j:
                distance = max(distances[i][j], epsilon)  # Avoid division by zero
                delta_p = np.clip(pressures[i] - pressures[j], -1e3, 1e3)  # Ensure pressures do not cause overflow
                fluxes[i][j] = (conductivities[i][j] / distance) * delta_p
    return fluxes

# Function to update conductivities
def update_conductivities(conductivities, fluxes, decay_rate, k, m):
    num_cities = len(conductivities)
    for i in range(num_cities):
        for j in range(num_cities):
            if i != j:
                flux = np.clip(abs(fluxes[i][j]), 0, 1e3)  # Control the size of the flux to prevent overflow
                growth = k * (flux ** m) - decay_rate * conductivities[i][j]
                growth = np.clip(growth, -1e2, 1e2)  # Limit the growth to prevent explosive updates
                conductivities[i][j] += growth + np.random.rand() * 0.001  # Add randomness to explore more paths
    return conductivities

# Function to update pressures
def update_pressures(pressures, fluxes, rate=0.05):
    num_cities = len(pressures)
    for i in range(num_cities):
        net_influx = np.sum(fluxes[:, i]) - np.sum(fluxes[i, :])
        pressures[i] += rate * net_influx
        pressures[i] = np.clip(pressures[i], 0, 1e2)  # Prevent pressure from becoming negative or excessively high
    return pressures

# Function to prune connections
def prune_connections(conductivities, threshold=0.005):
    conductivities[conductivities < threshold] = 0
    return conductivities

# Function to extract a TSP path using python-tsp
def extract_tsp_path(conductivities, distances):
    adjusted_distances = np.where(conductivities > 0, distances, np.inf)
    permutation, distance = solve_tsp_dynamic_programming(adjusted_distances)
    return permutation, distance

# Function to calculate the total distance of a given path
def calculate_total_distance(path, distances):
    total_distance = 0
    for i in range(len(path) - 1):
        if distances[path[i], path[i + 1]] == np.inf:
            print(f"Invalid distance between {path[i]} and {path[i + 1]}")
            return np.inf
        total_distance += distances[path[i], path[i + 1]]
    # Add the distance to return to the starting point
    if distances[path[-1], path[0]] == np.inf:
        print(f"Invalid distance between {path[-1]} and {path[0]}")
        return np.inf
    total_distance += distances[path[-1], path[0]]
    return total_distance

# Function to calculate memory usage
def calculate_memory_usage(conductivities):
    return conductivities.nbytes

from python_tsp.heuristics import solve_tsp_simulated_annealing

# Function to extract a TSP path using python-tsp simulated annealing
def extract_tsp_path_heuristic(distances):
    permutation, distance = solve_tsp_simulated_annealing(distances)
    return permutation, distance

# Simulation loop with best solution tracking and additional performance measures
num_iterations = 10
best_fitness = np.inf
best_path = None
best_distances = []
computation_times = []
convergence_rates = []
memory_usages = []
all_solutions = []
all_paths = []

start_time = time.time()

for iteration in range(num_iterations):
    iteration_start_time = time.time()

    fluxes = calculate_fluxes(pressures, conductivities, distances)
    pressures = update_pressures(pressures, fluxes)
    conductivities = update_conductivities(conductivities, fluxes, decay_rate, k, m)

    iteration_end_time = time.time()
    computation_times.append(iteration_end_time - iteration_start_time)

    conductivities = prune_connections(conductivities)
    current_path, current_fitness = extract_tsp_path_heuristic(distances)
    all_paths.append(current_path)
    all_solutions.append(current_fitness)

    if current_fitness < best_fitness:
        best_fitness = current_fitness
        best_path = current_path

    best_distances.append(best_fitness)
    convergence_rates.append(best_fitness)
    memory_usages.append(calculate_memory_usage(conductivities))

    # Print the length of the tour for the current best path
    if best_path is not None:
        tour_length = calculate_total_distance(best_path, distances)
        print(f"Iteration {iteration}, Best Path Length: {tour_length}")

total_computation_time = time.time() - start_time

print("Best Fitness:", best_fitness)
print("Best Path:", best_path)
print("Total Computation Time:", total_computation_time, "seconds")
print("Average Computation Time per Iteration:", np.mean(computation_times), "seconds")
print("Memory Usage:", memory_usages[-1], "bytes")

# Plotting the best path
def plot_best_path(best_path, cities):
    path_coords = cities[best_path]
    plt.figure(figsize=(10, 6))
    plt.plot(path_coords[:, 0], path_coords[:, 1], 'o-', markersize=10)
    plt.plot([path_coords[-1, 0], path_coords[0, 0]], [path_coords[-1, 1], path_coords[0, 1]], 'o-', markersize=10)  # Connect last to first
    for i, coord in enumerate(path_coords):
        plt.annotate(str(i + 1), (coord[0], coord[1]))
    plt.title("Best Path")
    plt.xlabel("X Coordinate")
    plt.ylabel("Y Coordinate")
    plt.grid(True)
    plt.show()

# Plotting the best fitness over iterations
def plot_best_fitness(best_distances):
    plt.figure(figsize=(10, 6))
    plt.plot(best_distances, 'o-', markersize=5)
    plt.title("Best Fitness over Iterations")
    plt.xlabel("Iteration")
    plt.ylabel("Total Distance (Fitness)")
    plt.grid(True)
    plt.show()

# Plotting the paths over selected iterations
def plot_paths_over_iterations(all_paths, cities, selected_iterations):
    plt.figure(figsize=(10, 6))
    for i in selected_iterations:
        path_coords = cities[all_paths[i]]
        plt.plot(path_coords[:, 0], path_coords[:, 1], 'o-', markersize=5, label=f"Iteration {i}")
        plt.plot([path_coords[-1, 0], path_coords[0, 0]], [path_coords[-1, 1], path_coords[0, 1]], 'o-', markersize=5)  # Connect last to first
    plt.title("Paths at Selected Iterations")
    plt.xlabel("X Coordinate")
    plt.ylabel("Y Coordinate")
    plt.legend()
    plt.grid(True)
    plt.show()

plot_best_path(best_path, cities)
plot_best_fitness(best_distances)
selected_iterations = list(range(0, num_iterations, 10))
plot_paths_over_iterations(all_paths, cities, selected_iterations)

"""#### Animation

"""

# Simulation loop with best solution tracking and additional performance measures
num_iterations = 50
best_fitness = np.inf
best_path = None
best_distances = []
computation_times = []
convergence_rates = []
memory_usages = []
all_solutions = []
all_paths = []

fig, ax = plt.subplots()

def update(frame):
    global pressures, conductivities, best_fitness, best_path

    iteration_start_time = time.time()

    fluxes = calculate_fluxes(pressures, conductivities, distances)
    pressures = update_pressures(pressures, fluxes)
    conductivities = update_conductivities(conductivities, fluxes, decay_rate, k, m)

    iteration_end_time = time.time()
    computation_times.append(iteration_end_time - iteration_start_time)

    conductivities = prune_connections(conductivities)
    current_path, current_fitness = extract_tsp_path_heuristic(distances)
    all_paths.append(current_path)
    all_solutions.append(current_fitness)

    if current_fitness < best_fitness:
        best_fitness = current_fitness
        best_path = current_path

    best_distances.append(best_fitness)
    convergence_rates.append(best_fitness)
    memory_usages.append(calculate_memory_usage(conductivities))

    # Clear the plot
    ax.clear()

    # Plot the cities
    ax.plot(cities[:, 0], cities[:, 1], 'o')

    # Plot the paths with conductivities
    for i in range(len(cities)):
        for j in range(len(cities)):
            if conductivities[i, j] > 0:
                ax.plot([cities[i, 0], cities[j, 0]], [cities[i, 1], cities[j, 1]], 'b-', alpha=conductivities[i, j])

    # Plot the best path
    if best_path is not None:
        path_coords = cities[best_path]
        ax.plot(path_coords[:, 0], path_coords[:, 1], 'r-', linewidth=2)
        ax.plot([path_coords[-1, 0], path_coords[0, 0]], [path_coords[-1, 1], path_coords[0, 1]], 'r-', linewidth=2)

    ax.set_title(f"Iteration {frame + 1}, Best Path Length: {best_fitness:.2f}")
    ax.set_xlabel("X Coordinate")
    ax.set_ylabel("Y Coordinate")
    ax.grid(True)

# Create the animation
ani = animation.FuncAnimation(fig, update, frames=num_iterations, repeat=False)

# Save the animation
ani.save('slime_mold_tsp_animation_ali_simulatedannealing.mp4', writer='ffmpeg')

# Display the animation
plt.show()

"""# FULL SLIME MODEL

## TSP extraction done with slime model
"""

!pip install tsplib95

import numpy as np
import gzip
import shutil
import matplotlib.pyplot as plt
import time
import pandas as pd
import networkx as nx
import tsplib95

# Function to extract .gz file
def extract_gzip(source_filepath, destination_filepath):
    with gzip.open(source_filepath, 'rb') as f_in, open(destination_filepath, 'wb') as f_out:
        shutil.copyfileobj(f_in, f_out)

# Function to load coordinates from the .tsp file
def load_coordinates(file_path):
    coordinates = []
    start_reading = False
    with open(file_path, 'r') as file:
        for line in file:
            if "NODE_COORD_SECTION" in line:
                start_reading = True
            elif "EOF" in line:
                break
            elif start_reading:
                parts = line.strip().split()
                if len(parts) == 3 and parts[0].isdigit():
                    coordinates.append((float(parts[1]), float(parts[2])))
    return coordinates

# Function to calculate geographical distances using the Haversine formula
# def haversine(coord1, coord2):
#     R = 6371.0  # Radius of the Earth in km
#     lat1, lon1 = np.radians(coord1)
#     lat2, lon2 = np.radians(coord2)
#     dlat = lat2 - lat1
#     dlon = lon2 - lon1
#     a = np.sin(dlat / 2)**2 + np.cos(lat1) * np.cos(lat2) * np.sin(dlon / 2)**2
#     c = 2 * np.arctan2(np.sqrt(a), np.sqrt(1 - a))
#     distance = R * c
#     return distance

# Extract and load city coordinates
source_filepath = 'burma14.tsp.gz'
destination_filepath = 'burma14.tsp'
extract_gzip(source_filepath, destination_filepath)
cities = np.array(load_coordinates(destination_filepath))
print("Loaded coordinates for", len(cities), "cities.")

with open(destination_filepath) as f:
  text = f.read()

problem = tsplib95.parse(text)
full_matrix = nx.adjacency_matrix(problem.get_graph()).todense()
distances = np.array(full_matrix)
distances = distances.astype(float)
distances[distances == 1] = np.inf

# # Calculate distance matrix
# def calculate_distances(cities):
#     num_cities = len(cities)
#     distances = np.zeros((num_cities, num_cities))
#     for i in range(num_cities):
#         for j in range(num_cities):
#             if i != j:
#                 distances[i, j] = haversine(cities[i], cities[j])
#             else:
#                 distances[i, j] = np.inf
#     return distances

# distances = calculate_distances(cities)
print("Distance matrix:")
print(distances)

# Initialize pressures and conductivities
pressures = np.random.rand(len(cities)) * 10
conductivities = np.ones_like(distances) * 0.01  # Initial small value for all conductivities

decay_rate = 0.1
k = 0.1
m = 2
epsilon = 1e-10

# Function to calculate fluxes
def calculate_fluxes(pressures, conductivities, distances, epsilon=1e-10):
    num_cities = len(pressures)
    fluxes = np.zeros((num_cities, num_cities))
    for i in range(num_cities):
        for j in range(num_cities):
            if i != j:
                distance = max(distances[i][j], epsilon)  # Avoid division by zero
                delta_p = np.clip(pressures[i] - pressures[j], -1e3, 1e3)  # Ensure pressures do not cause overflow
                fluxes[i][j] = (conductivities[i][j] / distance) * delta_p
    return fluxes

# Function to update conductivities
def update_conductivities(conductivities, fluxes, decay_rate, k, m):
    num_cities = len(conductivities)
    for i in range(num_cities):
        for j in range(num_cities):
            if i != j:
                flux = np.clip(abs(fluxes[i][j]), 0, 1e3)  # Control the size of the flux to prevent overflow
                growth = k * (flux ** m) - decay_rate * conductivities[i][j]
                growth = np.clip(growth, -1e2, 1e2)  # Limit the growth to prevent explosive updates
                conductivities[i][j] += growth + np.random.rand() * 0.001  # Add randomness to explore more paths
    return conductivities

# Function to update pressures
def update_pressures(pressures, fluxes, rate=0.05):
    num_cities = len(pressures)
    for i in range(num_cities):
        net_influx = np.sum(fluxes[:, i]) - np.sum(fluxes[i, :])
        pressures[i] += rate * net_influx
        pressures[i] = np.clip(pressures[i], 0, 1e2)  # Prevent pressure from becoming negative or excessively high
    return pressures

# Function to prune connections
def prune_connections(conductivities, threshold=0.005):
    conductivities[conductivities < threshold] = 0
    return conductivities

# Function to construct TSP path from conductivities
def construct_tsp_path(conductivities):
    num_cities = len(conductivities)
    visited = np.zeros(num_cities, dtype=bool)
    path = []

    current_city = 0
    path.append(current_city)
    visited[current_city] = True

    while len(path) < num_cities:
        next_city = np.argmax(conductivities[current_city] * (~visited))
        if conductivities[current_city][next_city] == 0:
            break
        path.append(next_city)
        visited[next_city] = True
        current_city = next_city

    if len(path) == num_cities:
        path.append(path[0])  # Return to the starting city
    else:
        print("Unable to construct a valid path. Conductivities might not have converged properly.")
        path = None

    return path

# Function to calculate the total distance of a given path
def calculate_total_distance(path, distances):
    total_distance = 0
    for i in range(len(path) - 1):
        if distances[path[i], path[i + 1]] == np.inf:
            print(f"Invalid distance between {path[i]} and {path[i + 1]}")
            return np.inf
        total_distance += distances[path[i], path[i + 1]]
    return total_distance

# Function to calculate memory usage
def calculate_memory_usage(conductivities):
    return conductivities.nbytes

# Function to plot the best path
def plot_best_path(best_path, cities):
    path_coords = cities[best_path]
    plt.figure(figsize=(10, 6))
    plt.plot(path_coords[:, 0], path_coords[:, 1], 'o-', markersize=10)
    plt.plot([path_coords[-1, 0], path_coords[0, 0]], [path_coords[-1, 1], path_coords[0, 1]], 'o-', markersize=10)  # Connect last to first
    for i, coord in enumerate(path_coords):
        plt.annotate(str(i + 1), (coord[0], coord[1]))
    plt.title("Best Path")
    plt.xlabel("X Coordinate")
    plt.ylabel("Y Coordinate")
    plt.grid(True)
    plt.show()

# Function to plot the fitness over iterations
def plot_fitness_over_iterations(all_fitness):
    plt.figure(figsize=(10, 6))
    plt.plot(all_fitness, 'o-', markersize=5)
    plt.title("Fitness over Iterations")
    plt.xlabel("Iteration")
    plt.ylabel("Total Distance (Fitness)")
    plt.grid(True)
    plt.show()

# Simulation loop
num_iterations = 50
best_fitness = np.inf
best_path = None
best_distances = []
computation_times = []
convergence_rates = []
memory_usages = []
all_solutions = []
all_paths = []

start_time = time.time()

for iteration in range(num_iterations):
    iteration_start_time = time.time()

    fluxes = calculate_fluxes(pressures, conductivities, distances)
    pressures = update_pressures(pressures, fluxes)
    conductivities = update_conductivities(conductivities, fluxes, decay_rate, k, m)

    iteration_end_time = time.time()
    computation_times.append(iteration_end_time - iteration_start_time)

    conductivities = prune_connections(conductivities)
    current_path = construct_tsp_path(conductivities)
    if current_path is None:
        continue

    current_fitness = calculate_total_distance(current_path, distances)
    all_paths.append(current_path)
    all_solutions.append(current_fitness)

    if current_fitness < best_fitness:
        best_fitness = current_fitness
        best_path = current_path

    best_distances.append(best_fitness)
    convergence_rates.append(best_fitness)
    memory_usages.append(calculate_memory_usage(conductivities))

    # Print the length of the tour for the current best path
    # if best_path is not None:
    #     tour_length = calculate_total_distance(best_path, distances)
    #     print(f"Iteration {iteration}, Best Path Length: {tour_length}")

total_computation_time = time.time() - start_time

print("Best Fitness:", best_fitness)
print("Best Path:", best_path)
print("Total Computation Time:", total_computation_time, "seconds")
print("Average Computation Time per Iteration:", np.mean(computation_times), "seconds")
print("Memory Usage:", memory_usages[-1], "bytes")

plot_fitness_over_iterations(all_solutions)
plot_best_path(best_path, cities)



"""### Animation"""

import numpy as np
import gzip
import shutil
import matplotlib.pyplot as plt
import time
import pandas as pd
import networkx as nx
import tsplib95

# Function to extract .gz file
def extract_gzip(source_filepath, destination_filepath):
    with gzip.open(source_filepath, 'rb') as f_in, open(destination_filepath, 'wb') as f_out:
        shutil.copyfileobj(f_in, f_out)

# Function to load coordinates from the .tsp file
def load_coordinates(file_path):
    coordinates = []
    start_reading = False
    with open(file_path, 'r') as file:
        for line in file:
            if "NODE_COORD_SECTION" in line:
                start_reading = True
            elif "EOF" in line:
                break
            elif start_reading:
                parts = line.strip().split()
                if len(parts) == 3 and parts[0].isdigit():
                    coordinates.append((float(parts[1]), float(parts[2])))
    return coordinates

# Function to calculate geographical distances using the Haversine formula
# def haversine(coord1, coord2):
#     R = 6371.0  # Radius of the Earth in km
#     lat1, lon1 = np.radians(coord1)
#     lat2, lon2 = np.radians(coord2)
#     dlat = lat2 - lat1
#     dlon = lon2 - lon1
#     a = np.sin(dlat / 2)**2 + np.cos(lat1) * np.cos(lat2) * np.sin(dlon / 2)**2
#     c = 2 * np.arctan2(np.sqrt(a), np.sqrt(1 - a))
#     distance = R * c
#     return distance

# Extract and load city coordinates
source_filepath = 'burma14.tsp.gz'
destination_filepath = 'burma14.tsp'
extract_gzip(source_filepath, destination_filepath)
cities = np.array(load_coordinates(destination_filepath))
print("Loaded coordinates for", len(cities), "cities.")

with open(destination_filepath) as f:
  text = f.read()

problem = tsplib95.parse(text)
full_matrix = nx.adjacency_matrix(problem.get_graph()).todense()
distances = np.array(full_matrix)
distances = distances.astype(float)
distances[distances == 1] = np.inf

# # Calculate distance matrix
# def calculate_distances(cities):
#     num_cities = len(cities)
#     distances = np.zeros((num_cities, num_cities))
#     for i in range(num_cities):
#         for j in range(num_cities):
#             if i != j:
#                 distances[i, j] = haversine(cities[i], cities[j])
#             else:
#                 distances[i, j] = np.inf
#     return distances

# distances = calculate_distances(cities)
print("Distance matrix:")
print(distances)

# Initialize pressures and conductivities
pressures = np.random.rand(len(cities)) * 10
conductivities = np.ones_like(distances) * 0.01  # Initial small value for all conductivities

decay_rate = 0.1
k = 0.1
m = 2
epsilon = 1e-10

# Function to calculate fluxes
def calculate_fluxes(pressures, conductivities, distances, epsilon=1e-10):
    num_cities = len(pressures)
    fluxes = np.zeros((num_cities, num_cities))
    for i in range(num_cities):
        for j in range(num_cities):
            if i != j:
                distance = max(distances[i][j], epsilon)  # Avoid division by zero
                delta_p = np.clip(pressures[i] - pressures[j], -1e3, 1e3)  # Ensure pressures do not cause overflow
                fluxes[i][j] = (conductivities[i][j] / distance) * delta_p
    return fluxes

# Function to update conductivities
def update_conductivities(conductivities, fluxes, decay_rate, k, m):
    num_cities = len(conductivities)
    for i in range(num_cities):
        for j in range(num_cities):
            if i != j:
                flux = np.clip(abs(fluxes[i][j]), 0, 1e3)  # Control the size of the flux to prevent overflow
                growth = k * (flux ** m) - decay_rate * conductivities[i][j]
                growth = np.clip(growth, -1e2, 1e2)  # Limit the growth to prevent explosive updates
                conductivities[i][j] += growth + np.random.rand() * 0.001  # Add randomness to explore more paths
    return conductivities

# Function to update pressures
def update_pressures(pressures, fluxes, rate=0.05):
    num_cities = len(pressures)
    for i in range(num_cities):
        net_influx = np.sum(fluxes[:, i]) - np.sum(fluxes[i, :])
        pressures[i] += rate * net_influx
        pressures[i] = np.clip(pressures[i], 0, 1e2)  # Prevent pressure from becoming negative or excessively high
    return pressures

# Function to prune connections
def prune_connections(conductivities, threshold=0.005):
    conductivities[conductivities < threshold] = 0
    return conductivities

# Function to construct TSP path from conductivities
def construct_tsp_path(conductivities):
    num_cities = len(conductivities)
    visited = np.zeros(num_cities, dtype=bool)
    path = []

    current_city = 0
    path.append(current_city)
    visited[current_city] = True

    while len(path) < num_cities:
        next_city = np.argmax(conductivities[current_city] * (~visited))
        if conductivities[current_city][next_city] == 0:
            break
        path.append(next_city)
        visited[next_city] = True
        current_city = next_city

    if len(path) == num_cities:
        path.append(path[0])  # Return to the starting city
    else:
        print("Unable to construct a valid path. Conductivities might not have converged properly.")
        path = None

    return path

# Function to calculate the total distance of a given path
def calculate_total_distance(path, distances):
    total_distance = 0
    for i in range(len(path) - 1):
        if distances[path[i], path[i + 1]] == np.inf:
            print(f"Invalid distance between {path[i]} and {path[i + 1]}")
            return np.inf
        total_distance += distances[path[i], path[i + 1]]
    return total_distance

# Function to calculate memory usage
def calculate_memory_usage(conductivities):
    return conductivities.nbytes

# Function to plot the best path
def plot_best_path(best_path, cities, ax=None):
    path_coords = cities[best_path]
    if ax is None:
        ax = plt.gca()
    ax.clear()
    ax.plot(path_coords[:, 0], path_coords[:, 1], 'o-', markersize=10)
    ax.plot([path_coords[-1, 0], path_coords[0, 0]], [path_coords[-1, 1], path_coords[0, 1]], 'o-', markersize=10)  # Connect last to first
    for i, coord in enumerate(path_coords):
        ax.annotate(str(i + 1), (coord[0], coord[1]))
    ax.set_title("Best Path")
    ax.set_xlabel("X Coordinate")
    ax.set_ylabel("Y Coordinate")
    ax.grid(True)

# Function to plot the fitness over iterations
def plot_fitness_over_iterations(all_fitness, ax=None):
    if ax is None:
        ax = plt.gca()
    ax.clear()
    ax.plot(all_fitness, 'o-', markersize=5)
    ax.set_title("Fitness over Iterations")
    ax.set_xlabel("Iteration")
    ax.set_ylabel("Total Distance (Fitness)")
    ax.grid(True)

# Simulation loop
num_iterations = 50
best_fitness = np.inf
best_path = None
best_distances = []
computation_times = []
convergence_rates = []
memory_usages = []
all_solutions = []
all_paths = []

start_time = time.time()

for iteration in range(num_iterations):
    iteration_start_time = time.time()

    fluxes = calculate_fluxes(pressures, conductivities, distances)
    pressures = update_pressures(pressures, fluxes)
    conductivities = update_conductivities(conductivities, fluxes, decay_rate, k, m)

    iteration_end_time = time.time()
    computation_times.append(iteration_end_time - iteration_start_time)

    conductivities = prune_connections(conductivities)
    current_path = construct_tsp_path(conductivities)
    if current_path is None:
        continue

    current_fitness = calculate_total_distance(current_path, distances)
    all_paths.append(current_path)
    all_solutions.append(current_fitness)

    if current_fitness < best_fitness:
        best_fitness = current_fitness
        best_path = current_path

    best_distances.append(best_fitness)
    convergence_rates.append(best_fitness)
    memory_usages.append(calculate_memory_usage(conductivities))

    # Print the length of the tour for the current best path
    if best_path is not None:
        tour_length = calculate_total_distance(best_path, distances)
        print(f"Iteration {iteration}, Best Path Length: {tour_length}")

total_computation_time = time.time() - start_time

print("Best Fitness:", best_fitness)
print("Best Path:", best_path)
print("Total Computation Time:", total_computation_time, "seconds")
print("Average Computation Time per Iteration:", np.mean(computation_times), "seconds")
print("Memory Usage:", memory_usages[-1], "bytes")

# Create animations
fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 12))

def update(frame):
    if frame < len(all_solutions):
        plot_fitness_over_iterations(all_solutions[:frame + 1], ax=ax1)
    if frame < len(all_paths):
        plot_best_path(all_paths[frame], cities, ax=ax2)
    return ax1, ax2

ani = FuncAnimation(fig, update, frames=num_iterations, blit=False)
ani.save('tsp_evolution.mp4', writer='ffmpeg')

plt.show()

"""##Final version - construct_tsp_path function improved with flux and pressures"""

import numpy as np
import gzip
import shutil
import matplotlib.pyplot as plt
import time
import pandas as pd
import networkx as nx
import tsplib95

# Function to extract .gz file
def extract_gzip(source_filepath, destination_filepath):
    with gzip.open(source_filepath, 'rb') as f_in, open(destination_filepath, 'wb') as f_out:
        shutil.copyfileobj(f_in, f_out)

# Function to load coordinates from the .tsp file
def load_coordinates(file_path):
    coordinates = []
    start_reading = False
    with open(file_path, 'r') as file:
        for line in file:
            if "NODE_COORD_SECTION" in line:
                start_reading = True
            elif "EOF" in line:
                break
            elif start_reading:
                parts = line.strip().split()
                if len(parts) == 3 and parts[0].isdigit():
                    coordinates.append((float(parts[1]), float(parts[2])))
    return coordinates

# Function to calculate geographical distances using the Haversine formula
# def haversine(coord1, coord2):
#     R = 6371.0  # Radius of the Earth in km
#     lat1, lon1 = np.radians(coord1)
#     lat2, lon2 = np.radians(coord2)
#     dlat = lat2 - lat1
#     dlon = lon2 - lon1
#     a = np.sin(dlat / 2)**2 + np.cos(lat1) * np.cos(lat2) * np.sin(dlon / 2)**2
#     c = 2 * np.arctan2(np.sqrt(a), np.sqrt(1 - a))
#     distance = R * c
#     return distance

# Extract and load city coordinates
source_filepath = 'burma14.tsp.gz'
destination_filepath = 'burma14.tsp'
extract_gzip(source_filepath, destination_filepath)
cities = np.array(load_coordinates(destination_filepath))
print("Loaded coordinates for", len(cities), "cities.")

with open(destination_filepath) as f:
  text = f.read()

problem = tsplib95.parse(text)
full_matrix = nx.adjacency_matrix(problem.get_graph()).todense()
distances = np.array(full_matrix)
distances = distances.astype(float)
distances[distances == 1] = np.inf

# # Calculate distance matrix
# def calculate_distances(cities):
#     num_cities = len(cities)
#     distances = np.zeros((num_cities, num_cities))
#     for i in range(num_cities):
#         for j in range(num_cities):
#             if i != j:
#                 distances[i, j] = haversine(cities[i], cities[j])
#             else:
#                 distances[i, j] = np.inf
#     return distances

# distances = calculate_distances(cities)
print("Distance matrix:")
print(distances)

# Initialize pressures and conductivities
pressures = np.random.rand(len(cities)) * 10
conductivities = np.ones_like(distances) * 0.01  # Initial small value for all conductivities

decay_rate = 0.1
k = 0.1
m = 2
epsilon = 1e-10

# Function to calculate fluxes
def calculate_fluxes(pressures, conductivities, distances, epsilon=1e-10):
    num_cities = len(pressures)
    fluxes = np.zeros((num_cities, num_cities))
    for i in range(num_cities):
        for j in range(num_cities):
            if i != j:
                distance = max(distances[i][j], epsilon)  # Avoid division by zero
                delta_p = np.clip(pressures[i] - pressures[j], -1e3, 1e3)  # Ensure pressures do not cause overflow
                fluxes[i][j] = (conductivities[i][j] / distance) * delta_p
    return fluxes

# Function to update conductivities
def update_conductivities(conductivities, fluxes, decay_rate, k, m):
    num_cities = len(conductivities)
    for i in range(num_cities):
        for j in range(num_cities):
            if i != j:
                flux = np.clip(abs(fluxes[i][j]), 0, 1e3)  # Control the size of the flux to prevent overflow
                growth = k * (flux ** m) - decay_rate * conductivities[i][j]
                growth = np.clip(growth, -1e2, 1e2)  # Limit the growth to prevent explosive updates
                conductivities[i][j] += growth + np.random.rand() * 0.001  # Add randomness to explore more paths
    return conductivities

# Function to update pressures
def update_pressures(pressures, fluxes, rate=0.05):
    num_cities = len(pressures)
    for i in range(num_cities):
        net_influx = np.sum(fluxes[:, i]) - np.sum(fluxes[i, :])
        pressures[i] += rate * net_influx
        pressures[i] = np.clip(pressures[i], 0, 1e2)  # Prevent pressure from becoming negative or excessively high
    return pressures

# Function to prune connections
def prune_connections(conductivities, threshold=0.005):
    conductivities[conductivities < threshold] = 0
    return conductivities

# Revised function to construct TSP path using both flux and conductivities
def construct_tsp_path(conductivities, fluxes):
    num_cities = len(conductivities)
    visited = np.zeros(num_cities, dtype=bool)
    degree = np.zeros(num_cities, dtype=int)
    path = []

    current_city = 0
    path.append(current_city)
    visited[current_city] = True
    degree[current_city] += 1

    while len(path) < num_cities:
        next_city = -1
        max_flux = -1

        for j in range(num_cities):
            if not visited[j] and fluxes[current_city][j] > max_flux and degree[current_city] < 2:
                next_city = j
                max_flux = fluxes[current_city][j]

        if next_city == -1:
            break

        path.append(next_city)
        visited[next_city] = True
        degree[current_city] += 1
        degree[next_city] += 1
        current_city = next_city

    if len(path) == num_cities:
        path.append(path[0])  # Return to the starting city
    else:
        print("Unable to construct a valid path. Conductivities might not have converged properly.")
        path = None

    return path

# Function to calculate the total distance of a given path
def calculate_total_distance(path, distances):
    total_distance = 0
    for i in range(len(path) - 1):
        if distances[path[i], path[i + 1]] == np.inf:
            print(f"Invalid distance between {path[i]} and {path[i + 1]}")
            return np.inf
        total_distance += distances[path[i], path[i + 1]]
    return total_distance

# Function to calculate memory usage
def calculate_memory_usage(conductivities):
    return conductivities.nbytes

# Function to plot the best path
def plot_best_path(best_path, cities, ax=None):
    path_coords = cities[best_path]
    if ax is None:
        ax = plt.gca()
    ax.clear()
    ax.plot(path_coords[:, 0], path_coords[:, 1], 'o-', markersize=10)
    ax.plot([path_coords[-1, 0], path_coords[0, 0]], [path_coords[-1, 1], path_coords[0, 1]], 'o-', markersize=10)  # Connect last to first
    for i, coord in enumerate(path_coords):
        ax.annotate(str(i + 1), (coord[0], coord[1]))
    ax.set_title("Best Path")
    ax.set_xlabel("X Coordinate")
    ax.set_ylabel("Y Coordinate")
    ax.grid(True)

# Function to plot the fitness over iterations
def plot_fitness_over_iterations(all_fitness, ax=None):
    if ax is None:
        ax = plt.gca()
    ax.clear()
    ax.plot(all_fitness, 'o-', markersize=5)
    ax.set_title("Fitness over Iterations")
    ax.set_xlabel("Iteration")
    ax.set_ylabel("Total Distance (Fitness)")
    ax.grid(True)

# Simulation loop
num_iterations = 500
best_fitness = np.inf
best_path = None
best_distances = []
computation_times = []
convergence_rates = []
memory_usages = []
all_solutions = []
all_paths = []

start_time = time.time()

for iteration in range(num_iterations):
    iteration_start_time = time.time()

    fluxes = calculate_fluxes(pressures, conductivities, distances)
    pressures = update_pressures(pressures, fluxes)
    conductivities = update_conductivities(conductivities, fluxes, decay_rate, k, m)

    iteration_end_time = time.time()
    computation_times.append(iteration_end_time - iteration_start_time)

    conductivities = prune_connections(conductivities)
    current_path = construct_tsp_path(conductivities, fluxes)
    if current_path is None:
        continue

    current_fitness = calculate_total_distance(current_path, distances)
    all_paths.append(current_path)
    all_solutions.append(current_fitness)

    if current_fitness < best_fitness:
        best_fitness = current_fitness
        best_path = current_path

    best_distances.append(best_fitness)
    convergence_rates.append(best_fitness)
    memory_usages.append(calculate_memory_usage(conductivities))

    # Print the length of the tour for the current best path
    if best_path is not None:
        tour_length = calculate_total_distance(best_path, distances)
        print(f"Iteration {iteration}, Best Path Length: {tour_length}")

total_computation_time = time.time() - start_time

print("Best Fitness:", best_fitness)
print("Best Path:", best_path)
print("Total Computation Time:", total_computation_time, "seconds")
print("Average Computation Time per Iteration:", np.mean(computation_times), "seconds")
print("Memory Usage:", memory_usages[-1], "bytes")

# Create animations
# fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 12))

# def update(frame):
#     if frame < len(all_solutions):
#         plot_fitness_over_iterations(all_solutions[:frame + 1], ax=ax1)
#     if frame < len(all_paths):
#         plot_best_path(all_paths[frame], cities, ax=ax2)
#     return ax1, ax2

# ani = FuncAnimation(fig, update, frames=num_iterations, blit=False)
# ani.save('tsp_evolution.mp4', writer='ffmpeg')

# plt.show()

plot_best_path(best_path, cities)

import numpy as np
import gzip
import shutil
import matplotlib.pyplot as plt
import time
import pandas as pd
import networkx as nx
import tsplib95

# Function to extract .gz file
def extract_gzip(source_filepath, destination_filepath):
    with gzip.open(source_filepath, 'rb') as f_in, open(destination_filepath, 'wb') as f_out:
        shutil.copyfileobj(f_in, f_out)

# Function to load coordinates from the .tsp file
def load_coordinates(file_path):
    coordinates = []
    start_reading = False
    with open(file_path, 'r') as file:
        for line in file:
            if "NODE_COORD_SECTION" in line:
                start_reading = True
            elif "EOF" in line:
                break
            elif start_reading:
                parts = line.strip().split()
                if len(parts) == 3 and parts[0].isdigit():
                    coordinates.append((float(parts[1]), float(parts[2])))
    return coordinates

# Function to calculate geographical distances using the Haversine formula
# def haversine(coord1, coord2):
#     R = 6371.0  # Radius of the Earth in km
#     lat1, lon1 = np.radians(coord1)
#     lat2, lon2 = np.radians(coord2)
#     dlat = lat2 - lat1
#     dlon = lon2 - lon1
#     a = np.sin(dlat / 2)**2 + np.cos(lat1) * np.cos(lat2) * np.sin(dlon / 2)**2
#     c = 2 * np.arctan2(np.sqrt(a), np.sqrt(1 - a))
#     distance = R * c
#     return distance

# Extract and load city coordinates
source_filepath = 'burma14.tsp.gz'
destination_filepath = 'burma14.tsp'
extract_gzip(source_filepath, destination_filepath)
cities = np.array(load_coordinates(destination_filepath))
print("Loaded coordinates for", len(cities), "cities.")

with open(destination_filepath) as f:
  text = f.read()

problem = tsplib95.parse(text)
full_matrix = nx.adjacency_matrix(problem.get_graph()).todense()
distances = np.array(full_matrix)
distances = distances.astype(float)
distances[distances == 1] = np.inf

# # Calculate distance matrix
# def calculate_distances(cities):
#     num_cities = len(cities)
#     distances = np.zeros((num_cities, num_cities))
#     for i in range(num_cities):
#         for j in range(num_cities):
#             if i != j:
#                 distances[i, j] = haversine(cities[i], cities[j])
#             else:
#                 distances[i, j] = np.inf
#     return distances

# distances = calculate_distances(cities)
print("Distance matrix:")
print(distances)

# Initialize pressures and conductivities
pressures = np.random.rand(len(cities)) * 10
conductivities = np.ones_like(distances) * 0.01  # Initial small value for all conductivities

decay_rate = 0.1
k = 0.1
m = 2
epsilon = 1e-10

# Function to calculate fluxes
def calculate_fluxes(pressures, conductivities, distances, epsilon=1e-10):
    num_cities = len(pressures)
    fluxes = np.zeros((num_cities, num_cities))
    for i in range(num_cities):
        for j in range(num_cities):
            if i != j:
                distance = max(distances[i][j], epsilon)  # Avoid division by zero
                delta_p = np.clip(pressures[i] - pressures[j], -1e3, 1e3)  # Ensure pressures do not cause overflow
                fluxes[i][j] = (conductivities[i][j] / distance) * delta_p
    return fluxes

# Function to update conductivities
def update_conductivities(conductivities, fluxes, decay_rate, k, m):
    num_cities = len(conductivities)
    for i in range(num_cities):
        for j in range(num_cities):
            if i != j:
                flux = np.clip(abs(fluxes[i][j]), 0, 1e3)  # Control the size of the flux to prevent overflow
                growth = k * (flux ** m) - decay_rate * conductivities[i][j]
                growth = np.clip(growth, -1e2, 1e2)  # Limit the growth to prevent explosive updates
                conductivities[i][j] += growth + np.random.rand() * 0.001  # Add randomness to explore more paths
    return conductivities

# Function to update pressures
def update_pressures(pressures, fluxes, rate=0.05):
    num_cities = len(pressures)
    for i in range(num_cities):
        net_influx = np.sum(fluxes[:, i]) - np.sum(fluxes[i, :])
        pressures[i] += rate * net_influx
        pressures[i] = np.clip(pressures[i], 0, 1e2)  # Prevent pressure from becoming negative or excessively high
    return pressures

# Function to prune connections
def prune_connections(conductivities, threshold=0.005):
    conductivities[conductivities < threshold] = 0
    return conductivities

# Revised function to construct TSP path using both flux and conductivities
def construct_tsp_path(conductivities, fluxes):
    num_cities = len(conductivities)
    visited = np.zeros(num_cities, dtype=bool)
    degree = np.zeros(num_cities, dtype=int)
    path = []

    current_city = 0
    path.append(current_city)
    visited[current_city] = True
    degree[current_city] += 1

    while len(path) < num_cities:
        next_city = -1
        max_flux = -1

        for j in range(num_cities): # I believe this leads towards the solution often being [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 0]
            if not visited[j] and fluxes[current_city][j] > max_flux and degree[current_city] < 2:
                next_city = j # So this should probably be handled differently for a better implementation (Idk how to do this better as I'm not quite sure what the conductivities and flux and stuff do)
                # Maybe you could sort them by conductivites? And then go through them one by one?
                max_flux = fluxes[current_city][j]

        if next_city == -1:
            break

        path.append(next_city)
        visited[next_city] = True
        degree[current_city] += 1
        degree[next_city] += 1
        current_city = next_city

    if len(path) == num_cities:
        path.append(path[0])  # Return to the starting city
    else:
        print("Unable to construct a valid path. Conductivities might not have converged properly.")
        path = None

    return path

# Function to calculate the total distance of a given path
def calculate_total_distance(path, distances):
    total_distance = 0
    for i in range(len(path) - 1):
        if distances[path[i], path[i + 1]] == np.inf:
            print(f"Invalid distance between {path[i]} and {path[i + 1]}")
            return np.inf
        total_distance += distances[path[i], path[i + 1]]
    return total_distance

# Function to calculate memory usage
def calculate_memory_usage(conductivities):
    return conductivities.nbytes

# Function to plot the best path
def plot_best_path(best_path, cities, ax=None):
    path_coords = cities[best_path]

    if ax is None:
        ax = plt.gca()
    else:
        ax.clear()

    ax.plot(path_coords[:, 0], path_coords[:, 1], 'o-', markersize=10)
    ax.plot([path_coords[-1, 0], path_coords[0, 0]], [path_coords[-1, 1], path_coords[0, 1]], 'o-', markersize=10)  # Connect last to first

    for i, coord in enumerate(path_coords):
        ax.annotate(str(best_path[i]), (coord[0], coord[1]))  # Use index from best_path for annotation

    ax.set_title("Best Path")
    ax.set_xlabel("X Coordinate")
    ax.set_ylabel("Y Coordinate")
    ax.grid(True)

# Function to plot the fitness over iterations
def plot_fitness_over_iterations(all_fitness, ax=None):
    if ax is None:
        ax = plt.gca()
    ax.clear()
    ax.plot(all_fitness, 'o-', markersize=5)
    ax.set_title("Fitness over Iterations")
    ax.set_xlabel("Iteration")
    ax.set_ylabel("Total Distance (Fitness)")
    ax.grid(True)

# Simulation loop
num_iterations = 100
best_fitness = np.inf
best_path = None
best_distances = []
computation_times = []
convergence_rates = []
memory_usages = []
all_solutions = []
all_paths = []

start_time = time.time()

for iteration in range(num_iterations):
    iteration_start_time = time.time()

    fluxes = calculate_fluxes(pressures, conductivities, distances)
    pressures = update_pressures(pressures, fluxes)
    conductivities = update_conductivities(conductivities, fluxes, decay_rate, k, m)

    iteration_end_time = time.time()
    computation_times.append(iteration_end_time - iteration_start_time)

    conductivities = prune_connections(conductivities)
    current_path = construct_tsp_path(conductivities, fluxes)
    if current_path is None:
        continue

    current_fitness = calculate_total_distance(current_path, distances)
    all_paths.append(current_path)
    all_solutions.append(current_fitness)

    if current_fitness < best_fitness:
        best_fitness = current_fitness
        best_path = current_path

    best_distances.append(best_fitness)
    convergence_rates.append(best_fitness)
    memory_usages.append(calculate_memory_usage(conductivities))

    # Print the length of the tour for the current best path
    if best_path is not None:
        tour_length = calculate_total_distance(best_path, distances)
        print(f"Iteration {iteration}, Best Path Length: {tour_length}")

total_computation_time = time.time() - start_time

print("Best Fitness:", best_fitness)
print("Best Path:", best_path)
print("Total Computation Time:", total_computation_time, "seconds")
print("Average Computation Time per Iteration:", np.mean(computation_times), "seconds")
print("Memory Usage:", memory_usages[-1], "bytes")

# Create animations
# fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 12))

# def update(frame):
#     if frame < len(all_solutions):
#         plot_fitness_over_iterations(all_solutions[:frame + 1], ax=ax1)
#     if frame < len(all_paths):
#         plot_best_path(all_paths[frame], cities, ax=ax2)
#     return ax1, ax2

# ani = FuncAnimation(fig, update, frames=num_iterations, blit=False)
# ani.save('tsp_evolution.mp4', writer='ffmpeg')

# plt.show()
plot_best_path(best_path, cities)

"""# Suggestions by fred implemented

"""

!pip install tsplib95

import numpy as np
import gzip
import shutil
import matplotlib.pyplot as plt
import time
import pandas as pd
import networkx as nx
import tsplib95

# Function to extract .gz file
def extract_gzip(source_filepath, destination_filepath):
    with gzip.open(source_filepath, 'rb') as f_in, open(destination_filepath, 'wb') as f_out:
        shutil.copyfileobj(f_in, f_out)

# Function to load coordinates from the .tsp file
def load_coordinates(file_path):
    coordinates = []
    start_reading = False
    with open(file_path, 'r') as file:
        for line in file:
            if "NODE_COORD_SECTION" in line:
                start_reading = True
            elif "EOF" in line:
                break
            elif start_reading:
                parts = line.strip().split()
                if len(parts) == 3 and parts[0].isdigit():
                    coordinates.append((float(parts[1]), float(parts[2])))
    return coordinates

# Function to calculate geographical distances using the Haversine formula
# def haversine(coord1, coord2):
#     R = 6371.0  # Radius of the Earth in km
#     lat1, lon1 = np.radians(coord1)
#     lat2, lon2 = np.radians(coord2)
#     dlat = lat2 - lat1
#     dlon = lon2 - lon1
#     a = np.sin(dlat / 2)**2 + np.cos(lat1) * np.cos(lat2) * np.sin(dlon / 2)**2
#     c = 2 * np.arctan2(np.sqrt(a), np.sqrt(1 - a))
#     distance = R * c
#     return distance

# Function to calculate fluxes
def calculate_fluxes(pressures, conductivities, distances, epsilon=1e-10):
    num_cities = len(pressures)
    fluxes = np.zeros((num_cities, num_cities))
    for i in range(num_cities):
        for j in range(num_cities):
            if i != j:
                distance = max(distances[i][j], epsilon)  # Avoid division by zero
                delta_p = np.clip(pressures[i] - pressures[j], -1e3, 1e3)  # Ensure pressures do not cause overflow
                fluxes[i][j] = (conductivities[i][j] / distance) * delta_p
    return fluxes

# Function to update conductivities
def update_conductivities(conductivities, fluxes, decay_rate, k, m):
    num_cities = len(conductivities)
    for i in range(num_cities):
        for j in range(num_cities):
            if i != j:
                flux = np.clip(abs(fluxes[i][j]), 0, 1e3)  # Control the size of the flux to prevent overflow
                growth = k * (flux ** m) - decay_rate * conductivities[i][j]
                growth = np.clip(growth, -1e2, 1e2)  # Limit the growth to prevent explosive updates
                conductivities[i][j] += growth + np.random.rand() * 0.001  # Add randomness to explore more paths
    return conductivities

# Function to update pressures
def update_pressures(pressures, fluxes, rate=0.05):
    num_cities = len(pressures)
    for i in range(num_cities):
        net_influx = np.sum(fluxes[:, i]) - np.sum(fluxes[i, :])
        pressures[i] += rate * net_influx
        pressures[i] = np.clip(pressures[i], 0, 1e2)  # Prevent pressure from becoming negative or excessively high
    return pressures

# Function to prune connections
def prune_connections(conductivities, threshold=0.005):
    conductivities[conductivities < threshold] = 0
    return conductivities

# Function to construct TSP path
def construct_tsp_path(conductivities, fluxes):
    num_cities = len(conductivities)
    visited = np.zeros(num_cities, dtype=bool)
    path = []

    current_city = 0
    path.append(current_city)
    visited[current_city] = True

    while len(path) < num_cities:
        next_city = -1
        max_value = -1

        for j in range(num_cities):
            if not visited[j]:
                value = conductivities[current_city][j] * fluxes[current_city][j]
                if value > max_value:
                    next_city = j
                    max_value = value

        if next_city == -1:
            break

        path.append(next_city)
        visited[next_city] = True
        current_city = next_city

    if len(path) == num_cities:
        path.append(path[0])  # Complete the tour by returning to the start

    return path

# Function to calculate the total distance of a given path
def calculate_total_distance(path, distances):
    total_distance = 0
    for i in range(len(path) - 1):
        if distances[path[i], path[i + 1]] == np.inf:
            print(f"Invalid distance between {path[i]} and {path[i + 1]}")
            return np.inf
        total_distance += distances[path[i], path[i + 1]]
    return total_distance

# Function to calculate memory usage
def calculate_memory_usage(conductivities):
    return conductivities.nbytes

# Function to plot the best path
def plot_best_path(best_path, cities, ax=None):
    path_coords = cities[best_path]

    if ax is None:
        ax = plt.gca()
    else:
        ax.clear()

    ax.plot(path_coords[:, 0], path_coords[:, 1], 'o-', markersize=10)
    ax.plot([path_coords[-1, 0], path_coords[0, 0]], [path_coords[-1, 1], path_coords[0, 1]], 'o-', markersize=10)  # Connect last to first

    for i, coord in enumerate(path_coords):
        ax.annotate(str(best_path[i]), (coord[0], coord[1]))  # Use index from best_path for annotation

    ax.set_title("Best Path")
    ax.set_xlabel("X Coordinate")
    ax.set_ylabel("Y Coordinate")
    ax.grid(True)

# Function to plot the fitness over iterations
def plot_fitness_over_iterations(all_fitness, ax=None):
    if ax is None:
        ax = plt.gca()
    ax.clear()
    ax.plot(all_fitness, 'o-', markersize=5)
    ax.set_title("Fitness over Iterations")
    ax.set_xlabel("Iteration")
    ax.set_ylabel("Total Distance (Fitness)")
    ax.grid(True)

# Simulation loop function
def run_simulation(dataset_name):
    # Extract and load city coordinates
    source_filepath = f'{dataset_name}.tsp.gz'
    destination_filepath = f'{dataset_name}.tsp'
    extract_gzip(source_filepath, destination_filepath)
    cities = np.array(load_coordinates(destination_filepath))
    print(f"Loaded coordinates for {len(cities)} cities from {dataset_name}.")

    with open(destination_filepath) as f:
        text = f.read()

    problem = tsplib95.parse(text)
    full_matrix = nx.adjacency_matrix(problem.get_graph()).todense()
    distances = np.array(full_matrix)
    distances = distances.astype(float)
    distances[distances == 1] = np.inf

    # Initialize pressures and conductivities
    pressures = np.random.rand(len(cities)) * 10
    conductivities = np.ones_like(distances) * 0.01  # Initial small value for all conductivities

    decay_rate = 0.1
    k = 0.1
    m = 2
    epsilon = 1e-10

    num_iterations = 100
    best_fitness = np.inf
    best_path = None
    best_distances = []
    computation_times = []
    convergence_rates = []
    memory_usages = []
    all_solutions = []
    all_paths = []

    start_time = time.time()

    for iteration in range(num_iterations):
        iteration_start_time = time.time()

        fluxes = calculate_fluxes(pressures, conductivities, distances)
        pressures = update_pressures(pressures, fluxes)
        conductivities = update_conductivities(conductivities, fluxes, decay_rate, k, m)

        iteration_end_time = time.time()
        computation_times.append(iteration_end_time - iteration_start_time)

        conductivities = prune_connections(conductivities)
        current_path = construct_tsp_path(conductivities, fluxes)
        if current_path is None:
            continue

        current_fitness = calculate_total_distance(current_path, distances)
        all_paths.append(current_path)
        all_solutions.append(current_fitness)

        if current_fitness < best_fitness:
            best_fitness = current_fitness
            best_path = current_path

        best_distances.append(best_fitness)
        convergence_rates.append(best_fitness)
        memory_usages.append(calculate_memory_usage(conductivities))

        # Print the length of the tour for the current best path
        if best_path is not None:
            tour_length = calculate_total_distance(best_path, distances)
            print(f"Iteration {iteration}, Best Path Length: {tour_length}")

    total_computation_time = time.time() - start_time

    print(f"Best Fitness for {dataset_name}:", best_fitness)
    print("Best Path:", best_path)
    print("Total Computation Time:", total_computation_time, "seconds")
    print("Average Computation Time per Iteration:", np.mean(computation_times), "seconds")
    print("Memory Usage:", memory_usages[-1], "bytes")

    # Plot the best path
    plt.figure()
    plot_best_path(best_path, cities)
    plt.title(f"Best Path for {dataset_name}")
    plt.show()

# Run simulation for each dataset
datasets = ['st70', 'ulysses22', 'ch150']
for dataset in datasets:
    run_simulation(dataset)

"""#FINAL EXPERIMENTS

## TSP WITH SLIME V1
"""

import numpy as np
import gzip
import shutil
import matplotlib.pyplot as plt
import time
import pandas as pd
import networkx as nx
import tsplib95

# Function to extract .gz file
def extract_gzip(source_filepath, destination_filepath):
    with gzip.open(source_filepath, 'rb') as f_in, open(destination_filepath, 'wb') as f_out:
        shutil.copyfileobj(f_in, f_out)

# Function to load coordinates from the .tsp file
def load_coordinates(file_path):
    coordinates = []
    start_reading = False
    with open(file_path, 'r') as file:
        for line in file:
            if "NODE_COORD_SECTION" in line:
                start_reading = True
            elif "EOF" in line:
                break
            elif start_reading:
                parts = line.strip().split()
                if len(parts) == 3 and parts[0].isdigit():
                    coordinates.append((float(parts[1]), float(parts[2])))
    return coordinates

# Function to calculate fluxes
def calculate_fluxes(pressures, conductivities, distances, epsilon=1e-10):
    num_cities = len(pressures)
    fluxes = np.zeros((num_cities, num_cities))
    for i in range(num_cities):
        for j in range(num_cities):
            if i != j:
                distance = max(distances[i][j], epsilon)  # Avoid division by zero
                delta_p = np.clip(pressures[i] - pressures[j], -1e3, 1e3)  # Ensure pressures do not cause overflow
                fluxes[i][j] = (conductivities[i][j] / distance) * delta_p
    return fluxes

# Function to update conductivities
def update_conductivities(conductivities, fluxes, decay_rate, k, m):
    num_cities = len(conductivities)
    for i in range(num_cities):
        for j in range(num_cities):
            if i != j:
                flux = np.clip(abs(fluxes[i][j]), 0, 1e3)  # Control the size of the flux to prevent overflow
                growth = k * (flux ** m) - decay_rate * conductivities[i][j]
                growth = np.clip(growth, -1e2, 1e2)  # Limit the growth to prevent explosive updates
                conductivities[i][j] += growth + np.random.rand() * 0.001  # Add randomness to explore more paths
    return conductivities

# Function to update pressures
def update_pressures(pressures, fluxes, rate=0.05):
    num_cities = len(pressures)
    for i in range(num_cities):
        net_influx = np.sum(fluxes[:, i]) - np.sum(fluxes[i, :])
        pressures[i] += rate * net_influx
        pressures[i] = np.clip(pressures[i], 0, 1e2)  # Prevent pressure from becoming negative or excessively high
    return pressures

# Function to prune connections
def prune_connections(conductivities, threshold=0.005):
    conductivities[conductivities < threshold] = 0
    return conductivities

# Function to construct TSP path from conductivities
def construct_tsp_path(conductivities):
    num_cities = len(conductivities)
    visited = np.zeros(num_cities, dtype=bool)
    path = []

    current_city = 0
    path.append(current_city)
    visited[current_city] = True

    while len(path) < num_cities:
        next_city = np.argmax(conductivities[current_city] * (~visited))
        if conductivities[current_city][next_city] == 0:
            break
        path.append(next_city)
        visited[next_city] = True
        current_city = next_city

    if len(path) == num_cities:
        path.append(path[0])  # Return to the starting city
    else:
        print("Unable to construct a valid path. Conductivities might not have converged properly.")
        path = None

    return path

# Function to calculate the total distance of a given path
def calculate_total_distance(path, distances):
    total_distance = 0
    for i in range(len(path) - 1):
        if distances[path[i], path[i + 1]] == np.inf:
            print(f"Invalid distance between {path[i]} and {path[i + 1]}")
            return np.inf
        total_distance += distances[path[i], path[i + 1]]
    return total_distance

# Function to calculate memory usage
def calculate_memory_usage(conductivities):
    return conductivities.nbytes

# Function to plot the best path
def plot_best_path(best_path, cities, dataset_name):
    path_coords = cities[best_path]
    plt.figure(figsize=(10, 6))
    plt.plot(path_coords[:, 0], path_coords[:, 1], 'o-', markersize=10)
    plt.plot([path_coords[-1, 0], path_coords[0, 0]], [path_coords[-1, 1], path_coords[0, 1]], 'o-', markersize=10)  # Connect last to first
    for i, coord in enumerate(path_coords):
        plt.annotate(str(i + 1), (coord[0], coord[1]))
    plt.title(f"Best Path for {dataset_name}")
    plt.xlabel("X Coordinate")
    plt.ylabel("Y Coordinate")
    plt.grid(True)
    plt.show()

# Function to plot the fitness over iterations
def plot_fitness_over_iterations(all_fitness, dataset_name):
    plt.figure(figsize=(10, 6))
    plt.plot(all_fitness, 'o-', markersize=5)
    plt.title(f"Fitness over Iterations for {dataset_name}")
    plt.xlabel("Iteration")
    plt.ylabel("Total Distance (Fitness)")
    plt.grid(True)
    plt.show()

# Simulation loop function
def run_simulation(dataset_name):
    # Extract and load city coordinates
    source_filepath = f'{dataset_name}.tsp.gz'
    destination_filepath = f'{dataset_name}.tsp'
    extract_gzip(source_filepath, destination_filepath)
    cities = np.array(load_coordinates(destination_filepath))
    print(f"Loaded coordinates for {len(cities)} cities from {dataset_name}.")

    with open(destination_filepath) as f:
        text = f.read()

    problem = tsplib95.parse(text)
    full_matrix = nx.adjacency_matrix(problem.get_graph()).todense()
    distances = np.array(full_matrix)
    distances = distances.astype(float)
    distances[distances == 1] = np.inf

    # Initialize pressures and conductivities
    pressures = np.random.rand(len(cities)) * 10
    conductivities = np.ones_like(distances) * 0.01  # Initial small value for all conductivities

    decay_rate = 0.1
    k = 0.1
    m = 2
    epsilon = 1e-10

    num_iterations = 50
    best_fitness = np.inf
    best_path = None
    best_distances = []
    computation_times = []
    convergence_rates = []
    memory_usages = []
    all_solutions = []
    all_paths = []

    start_time = time.time()

    for iteration in range(num_iterations):
        iteration_start_time = time.time()

        fluxes = calculate_fluxes(pressures, conductivities, distances)
        pressures = update_pressures(pressures, fluxes)
        conductivities = update_conductivities(conductivities, fluxes, decay_rate, k, m)

        iteration_end_time = time.time()
        computation_times.append(iteration_end_time - iteration_start_time)

        conductivities = prune_connections(conductivities)
        current_path = construct_tsp_path(conductivities)
        if current_path is None:
            continue

        current_fitness = calculate_total_distance(current_path, distances)
        all_paths.append(current_path)
        all_solutions.append(current_fitness)

        if current_fitness < best_fitness:
            best_fitness = current_fitness
            best_path = current_path

        best_distances.append(best_fitness)
        convergence_rates.append(best_fitness)
        memory_usages.append(calculate_memory_usage(conductivities))

        # Print the length of the tour for the current best path
        if best_path is not None:
            tour_length = calculate_total_distance(best_path, distances)
            print(f"Iteration {iteration}, Best Path Length: {tour_length}")

    total_computation_time = time.time() - start_time

    print(f"Best Fitness for {dataset_name}:", best_fitness)
    print("Best Path:", best_path)
    print("Total Computation Time:", total_computation_time, "seconds")
    print("Average Computation Time per Iteration:", np.mean(computation_times), "seconds")
    print("Memory Usage:", memory_usages[-1], "bytes")

    # Plot the results
    plot_fitness_over_iterations(all_solutions, dataset_name)
    plot_best_path(best_path, cities, dataset_name)

# Run simulation for each dataset
datasets = ['st70', 'ulysses22', 'ch150']
for dataset in datasets:
    run_simulation(dataset)

"""## TSP WITH SLIME V2"""

import numpy as np
import gzip
import shutil
import matplotlib.pyplot as plt
import time
import pandas as pd
import networkx as nx
import tsplib95

# Function to extract .gz file
def extract_gzip(source_filepath, destination_filepath):
    with gzip.open(source_filepath, 'rb') as f_in, open(destination_filepath, 'wb') as f_out:
        shutil.copyfileobj(f_in, f_out)

# Function to load coordinates from the .tsp file
def load_coordinates(file_path):
    coordinates = []
    start_reading = False
    with open(file_path, 'r') as file:
        for line in file:
            if "NODE_COORD_SECTION" in line:
                start_reading = True
            elif "EOF" in line:
                break
            elif start_reading:
                parts = line.strip().split()
                if len(parts) == 3 and parts[0].isdigit():
                    coordinates.append((float(parts[1]), float(parts[2])))
    return coordinates

# Function to calculate fluxes
def calculate_fluxes(pressures, conductivities, distances, epsilon=1e-10):
    num_cities = len(pressures)
    fluxes = np.zeros((num_cities, num_cities))
    for i in range(num_cities):
        for j in range(num_cities):
            if i != j:
                distance = max(distances[i][j], epsilon)  # Avoid division by zero
                delta_p = np.clip(pressures[i] - pressures[j], -1e3, 1e3)  # Ensure pressures do not cause overflow
                fluxes[i][j] = (conductivities[i][j] / distance) * delta_p
    return fluxes

# Function to update conductivities
def update_conductivities(conductivities, fluxes, decay_rate, k, m):
    num_cities = len(conductivities)
    for i in range(num_cities):
        for j in range(num_cities):
            if i != j:
                flux = np.clip(abs(fluxes[i][j]), 0, 1e3)  # Control the size of the flux to prevent overflow
                growth = k * (flux ** m) - decay_rate * conductivities[i][j]
                growth = np.clip(growth, -1e2, 1e2)  # Limit the growth to prevent explosive updates
                conductivities[i][j] += growth + np.random.rand() * 0.001  # Add randomness to explore more paths
    return conductivities

# Function to update pressures
def update_pressures(pressures, fluxes, rate=0.05):
    num_cities = len(pressures)
    for i in range(num_cities):
        net_influx = np.sum(fluxes[:, i]) - np.sum(fluxes[i, :])
        pressures[i] += rate * net_influx
        pressures[i] = np.clip(pressures[i], 0, 1e2)  # Prevent pressure from becoming negative or excessively high
    return pressures

# Function to prune connections
def prune_connections(conductivities, threshold=0.005):
    conductivities[conductivities < threshold] = 0
    return conductivities

# Function to construct TSP path from conductivities
def construct_tsp_path(conductivities, fluxes):
    num_cities = len(conductivities)
    visited = np.zeros(num_cities, dtype=bool)
    degree = np.zeros(num_cities, dtype=int)
    path = []

    current_city = 0
    path.append(current_city)
    visited[current_city] = True
    degree[current_city] += 1

    while len(path) < num_cities:
        next_city = -1
        max_flux = -1

        for j in range(num_cities):
            if not visited[j] and fluxes[current_city][j] > max_flux and degree[current_city] < 2:
                next_city = j
                max_flux = fluxes[current_city][j]

        if next_city == -1:
            break

        path.append(next_city)
        visited[next_city] = True
        degree[current_city] += 1
        degree[next_city] += 1
        current_city = next_city

    if len(path) == num_cities:
        path.append(path[0])  # Return to the starting city
    else:
        print("Unable to construct a valid path. Conductivities might not have converged properly.")
        path = None

    return path

# Function to calculate the total distance of a given path
def calculate_total_distance(path, distances):
    total_distance = 0
    for i in range(len(path) - 1):
        if distances[path[i], path[i + 1]] == np.inf:
            print(f"Invalid distance between {path[i]} and {path[i + 1]}")
            return np.inf
        total_distance += distances[path[i], path[i + 1]]
    return total_distance

# Function to calculate memory usage
def calculate_memory_usage(conductivities):
    return conductivities.nbytes

# Function to plot the best path
def plot_best_path(best_path, cities, dataset_name):
    path_coords = cities[best_path]
    plt.figure(figsize=(10, 6))
    plt.plot(path_coords[:, 0], path_coords[:, 1], 'o-', markersize=10)
    plt.plot([path_coords[-1, 0], path_coords[0, 0]], [path_coords[-1, 1], path_coords[0, 1]], 'o-', markersize=10)  # Connect last to first
    for i, coord in enumerate(path_coords):
        plt.annotate(str(i + 1), (coord[0], coord[1]))
    plt.title(f"Best Path for {dataset_name}")
    plt.xlabel("X Coordinate")
    plt.ylabel("Y Coordinate")
    plt.grid(True)
    plt.show()

# Function to plot the fitness over iterations
def plot_fitness_over_iterations(all_fitness, dataset_name):
    plt.figure(figsize=(10, 6))
    plt.plot(all_fitness, 'o-', markersize=5)
    plt.title(f"Fitness over Iterations for {dataset_name}")
    plt.xlabel("Iteration")
    plt.ylabel("Total Distance (Fitness)")
    plt.grid(True)
    plt.show()

# Simulation loop function
def run_simulation(dataset_name):
    # Extract and load city coordinates
    source_filepath = f'{dataset_name}.tsp.gz'
    destination_filepath = f'{dataset_name}.tsp'
    extract_gzip(source_filepath, destination_filepath)
    cities = np.array(load_coordinates(destination_filepath))
    print(f"Loaded coordinates for {len(cities)} cities from {dataset_name}.")

    with open(destination_filepath) as f:
        text = f.read()

    problem = tsplib95.parse(text)
    full_matrix = nx.adjacency_matrix(problem.get_graph()).todense()
    distances = np.array(full_matrix)
    distances = distances.astype(float)
    distances[distances == 1] = np.inf

    # Initialize pressures and conductivities
    pressures = np.random.rand(len(cities)) * 10
    conductivities = np.ones_like(distances) * 0.01  # Initial small value for all conductivities

    decay_rate = 0.1
    k = 0.1
    m = 2
    epsilon = 1e-10

    num_iterations = 500
    best_fitness = np.inf
    best_path = None
    best_distances = []
    computation_times = []
    convergence_rates = []
    memory_usages = []
    all_solutions = []
    all_paths = []

    start_time = time.time()

    for iteration in range(num_iterations):
        iteration_start_time = time.time()

        fluxes = calculate_fluxes(pressures, conductivities, distances)
        pressures = update_pressures(pressures, fluxes)
        conductivities = update_conductivities(conductivities, fluxes, decay_rate, k, m)

        iteration_end_time = time.time()
        computation_times.append(iteration_end_time - iteration_start_time)

        conductivities = prune_connections(conductivities)
        current_path = construct_tsp_path(conductivities, fluxes)
        if current_path is None:
            continue

        current_fitness = calculate_total_distance(current_path, distances)
        all_paths.append(current_path)
        all_solutions.append(current_fitness)

        if current_fitness < best_fitness:
            best_fitness = current_fitness
            best_path = current_path

        best_distances.append(best_fitness)
        convergence_rates.append(best_fitness)
        memory_usages.append(calculate_memory_usage(conductivities))

        # Print the length of the tour for the current best path
        if best_path is not None:
            tour_length = calculate_total_distance(best_path, distances)
            print(f"Iteration {iteration}, Best Path Length: {tour_length}")

    total_computation_time = time.time() - start_time

    print(f"Best Fitness for {dataset_name}:", best_fitness)
    print("Best Path:", best_path)
    print("Total Computation Time:", total_computation_time, "seconds")
    print("Average Computation Time per Iteration:", np.mean(computation_times), "seconds")
    print("Memory Usage:", memory_usages[-1], "bytes")

    # Plot the results
    plot_fitness_over_iterations(all_solutions, dataset_name)
    plot_best_path(best_path, cities, dataset_name)

# Run simulations for each dataset
datasets = ['st70', 'ulysses22', 'ch150']
for dataset in datasets:
    run_simulation(dataset)

"""## TSP WITH SLIME V3- fred"""

import numpy as np
import gzip
import shutil
import matplotlib.pyplot as plt
import time
import pandas as pd
import networkx as nx
import tsplib95

# Function to extract .gz file
def extract_gzip(source_filepath, destination_filepath):
    with gzip.open(source_filepath, 'rb') as f_in, open(destination_filepath, 'wb') as f_out:
        shutil.copyfileobj(f_in, f_out)

# Function to load coordinates from the .tsp file
def load_coordinates(file_path):
    coordinates = []
    start_reading = False
    with open(file_path, 'r') as file:
        for line in file:
            if "NODE_COORD_SECTION" in line:
                start_reading = True
            elif "EOF" in line:
                break
            elif start_reading:
                parts = line.strip().split()
                if len(parts) == 3 and parts[0].isdigit():
                    coordinates.append((float(parts[1]), float(parts[2])))
    return coordinates

# Function to calculate geographical distances using the Haversine formula
# def haversine(coord1, coord2):
#     R = 6371.0  # Radius of the Earth in km
#     lat1, lon1 = np.radians(coord1)
#     lat2, lon2 = np.radians(coord2)
#     dlat = lat2 - lat1
#     dlon = lon2 - lon1
#     a = np.sin(dlat / 2)**2 + np.cos(lat1) * np.cos(lat2) * np.sin(dlon / 2)**2
#     c = 2 * np.arctan2(np.sqrt(a), np.sqrt(1 - a))
#     distance = R * c
#     return distance

# Function to calculate fluxes
def calculate_fluxes(pressures, conductivities, distances, epsilon=1e-10):
    num_cities = len(pressures)
    fluxes = np.zeros((num_cities, num_cities))
    for i in range(num_cities):
        for j in range(num_cities):
            if i != j:
                distance = max(distances[i][j], epsilon)  # Avoid division by zero
                delta_p = np.clip(pressures[i] - pressures[j], -1e3, 1e3)  # Ensure pressures do not cause overflow
                fluxes[i][j] = (conductivities[i][j] / distance) * delta_p
    return fluxes

# Function to update conductivities
def update_conductivities(conductivities, fluxes, decay_rate, k, m):
    num_cities = len(conductivities)
    for i in range(num_cities):
        for j in range(num_cities):
            if i != j:
                flux = np.clip(abs(fluxes[i][j]), 0, 1e3)  # Control the size of the flux to prevent overflow
                growth = k * (flux ** m) - decay_rate * conductivities[i][j]
                growth = np.clip(growth, -1e2, 1e2)  # Limit the growth to prevent explosive updates
                conductivities[i][j] += growth + np.random.rand() * 0.001  # Add randomness to explore more paths
    return conductivities

# Function to update pressures
def update_pressures(pressures, fluxes, rate=0.05):
    num_cities = len(pressures)
    for i in range(num_cities):
        net_influx = np.sum(fluxes[:, i]) - np.sum(fluxes[i, :])
        pressures[i] += rate * net_influx
        pressures[i] = np.clip(pressures[i], 0, 1e2)  # Prevent pressure from becoming negative or excessively high
    return pressures

# Function to prune connections
def prune_connections(conductivities, threshold=0.005):
    conductivities[conductivities < threshold] = 0
    return conductivities

# Function to construct TSP path
def construct_tsp_path(conductivities, fluxes):
    num_cities = len(conductivities)
    visited = np.zeros(num_cities, dtype=bool)
    path = []

    current_city = 0
    path.append(current_city)
    visited[current_city] = True

    while len(path) < num_cities:
        next_city = -1
        max_value = -1

        for j in range(num_cities):
            if not visited[j]:
                value = conductivities[current_city][j] * fluxes[current_city][j]
                if value > max_value:
                    next_city = j
                    max_value = value

        if next_city == -1:
            break

        path.append(next_city)
        visited[next_city] = True
        current_city = next_city

    if len(path) == num_cities:
        path.append(path[0])  # Complete the tour by returning to the start

    return path

# Function to calculate the total distance of a given path
def calculate_total_distance(path, distances):
    total_distance = 0
    for i in range(len(path) - 1):
        if distances[path[i], path[i + 1]] == np.inf:
            print(f"Invalid distance between {path[i]} and {path[i + 1]}")
            return np.inf
        total_distance += distances[path[i], path[i + 1]]
    return total_distance

# Function to calculate memory usage
def calculate_memory_usage(conductivities):
    return conductivities.nbytes

# Function to plot the best path
def plot_best_path(best_path, cities, ax=None):
    path_coords = cities[best_path]

    if ax is None:
        ax = plt.gca()
    else:
        ax.clear()

    ax.plot(path_coords[:, 0], path_coords[:, 1], 'o-', markersize=10)
    ax.plot([path_coords[-1, 0], path_coords[0, 0]], [path_coords[-1, 1], path_coords[0, 1]], 'o-', markersize=10)  # Connect last to first

    for i, coord in enumerate(path_coords):
        ax.annotate(str(best_path[i]), (coord[0], coord[1]))  # Use index from best_path for annotation

    ax.set_title("Best Path")
    ax.set_xlabel("X Coordinate")
    ax.set_ylabel("Y Coordinate")
    ax.grid(True)

# Function to plot the fitness over iterations
def plot_fitness_over_iterations(all_fitness, ax=None):
    if ax is None:
        ax = plt.gca()
    ax.clear()
    ax.plot(all_fitness, 'o-', markersize=5)
    ax.set_title("Fitness over Iterations")
    ax.set_xlabel("Iteration")
    ax.set_ylabel("Total Distance (Fitness)")
    ax.grid(True)

# Simulation loop function
def run_simulation(dataset_name):
    # Extract and load city coordinates
    source_filepath = f'{dataset_name}.tsp.gz'
    destination_filepath = f'{dataset_name}.tsp'
    extract_gzip(source_filepath, destination_filepath)
    cities = np.array(load_coordinates(destination_filepath))
    print(f"Loaded coordinates for {len(cities)} cities from {dataset_name}.")

    with open(destination_filepath) as f:
        text = f.read()

    problem = tsplib95.parse(text)
    full_matrix = nx.adjacency_matrix(problem.get_graph()).todense()
    distances = np.array(full_matrix)
    distances = distances.astype(float)
    distances[distances == 1] = np.inf

    # Initialize pressures and conductivities
    pressures = np.random.rand(len(cities)) * 10
    conductivities = np.ones_like(distances) * 0.01  # Initial small value for all conductivities

    decay_rate = 0.1
    k = 0.1
    m = 2
    epsilon = 1e-10

    num_iterations = 100
    best_fitness = np.inf
    best_path = None
    best_distances = []
    computation_times = []
    convergence_rates = []
    memory_usages = []
    all_solutions = []
    all_paths = []

    start_time = time.time()

    for iteration in range(num_iterations):
        iteration_start_time = time.time()

        fluxes = calculate_fluxes(pressures, conductivities, distances)
        pressures = update_pressures(pressures, fluxes)
        conductivities = update_conductivities(conductivities, fluxes, decay_rate, k, m)

        iteration_end_time = time.time()
        computation_times.append(iteration_end_time - iteration_start_time)

        conductivities = prune_connections(conductivities)
        current_path = construct_tsp_path(conductivities, fluxes)
        if current_path is None:
            continue

        current_fitness = calculate_total_distance(current_path, distances)
        all_paths.append(current_path)
        all_solutions.append(current_fitness)

        if current_fitness < best_fitness:
            best_fitness = current_fitness
            best_path = current_path

        best_distances.append(best_fitness)
        convergence_rates.append(best_fitness)
        memory_usages.append(calculate_memory_usage(conductivities))

        # Print the length of the tour for the current best path
        if best_path is not None:
            tour_length = calculate_total_distance(best_path, distances)
            print(f"Iteration {iteration}, Best Path Length: {tour_length}")

    total_computation_time = time.time() - start_time

    print(f"Best Fitness for {dataset_name}:", best_fitness)
    print("Best Path:", best_path)
    print("Total Computation Time:", total_computation_time, "seconds")
    print("Average Computation Time per Iteration:", np.mean(computation_times), "seconds")
    print("Memory Usage:", memory_usages[-1], "bytes")

    # Plot the best path
    plt.figure()
    plot_best_path(best_path, cities)
    plt.title(f"Best Path for {dataset_name}")
    plt.show()

# Run simulation for each dataset
datasets = ['st70', 'ulysses22', 'ch150']
for dataset in datasets:
    run_simulation(dataset)

"""## TSP WITH simulated annealing"""

!pip install python_tsp

import numpy as np
import matplotlib.pyplot as plt
import time
from python_tsp.heuristics import solve_tsp_simulated_annealing
import sys
sys.setrecursionlimit(10000)

# Function to load coordinates from the .tsp file
def load_coordinates(file_path):
    coordinates = []
    start_reading = False
    with open(file_path, 'r') as file:
        for line in file:
            if "NODE_COORD_SECTION" in line:
                start_reading = True
            elif "EOF" in line:
                break
            elif start_reading:
                parts = line.strip().split()
                if len(parts) == 3 and parts[0].isdigit():
                    coordinates.append((float(parts[1]), float(parts[2])))
    return coordinates

# Function to calculate geographical distances using the Haversine formula
def haversine(coord1, coord2):
    R = 6371.0  # Radius of the Earth in km
    lat1, lon1 = np.radians(coord1)
    lat2, lon2 = np.radians(coord2)
    dlat = lat2 - lat1
    dlon = lon2 - lon1
    a = np.sin(dlat / 2)**2 + np.cos(lat1) * np.cos(lat2) * np.sin(dlon / 2)**2
    c = 2 * np.arctan2(np.sqrt(a), np.sqrt(1 - a))
    distance = R * c
    return distance

# Function to calculate distance matrix
def calculate_distances(cities):
    num_cities = len(cities)
    distances = np.zeros((num_cities, num_cities))
    for i in range(num_cities):
        for j in range(num_cities):
            if i != j:
                distances[i, j] = haversine(cities[i], cities[j])
            else:
                distances[i, j] = np.inf
    return distances

# Function to calculate fluxes
def calculate_fluxes(pressures, conductivities, distances, epsilon=1e-10):
    num_cities = len(pressures)
    fluxes = np.zeros((num_cities, num_cities))
    for i in range(num_cities):
        for j in range(num_cities):
            if i != j:
                distance = max(distances[i][j], epsilon)  # Avoid division by zero
                delta_p = np.clip(pressures[i] - pressures[j], -1e3, 1e3)  # Ensure pressures do not cause overflow
                fluxes[i][j] = (conductivities[i][j] / distance) * delta_p
    return fluxes

# Function to update conductivities
def update_conductivities(conductivities, fluxes, decay_rate, k, m):
    num_cities = len(conductivities)
    for i in range(num_cities):
        for j in range(num_cities):
            if i != j:
                flux = np.clip(abs(fluxes[i][j]), 0, 1e3)  # Control the size of the flux to prevent overflow
                growth = k * (flux ** m) - decay_rate * conductivities[i][j]
                growth = np.clip(growth, -1e2, 1e2)  # Limit the growth to prevent explosive updates
                conductivities[i][j] += growth + np.random.rand() * 0.001  # Add randomness to explore more paths
    return conductivities

# Function to update pressures
def update_pressures(pressures, fluxes, rate=0.05):
    num_cities = len(pressures)
    for i in range(num_cities):
        net_influx = np.sum(fluxes[:, i]) - np.sum(fluxes[i, :])
        pressures[i] += rate * net_influx
        pressures[i] = np.clip(pressures[i], 0, 1e2)  # Prevent pressure from becoming negative or excessively high
    return pressures

# Function to prune connections
def prune_connections(conductivities, threshold=0.005):
    conductivities[conductivities < threshold] = 0
    return conductivities

# Function to extract a TSP path using python-tsp simulated annealing
def extract_tsp_path_heuristic(distances):
    permutation, distance = solve_tsp_simulated_annealing(distances)
    return permutation, distance

# Function to calculate the total distance of a given path
def calculate_total_distance(path, distances):
    total_distance = 0
    for i in range(len(path) - 1):
        if distances[path[i], path[i + 1]] == np.inf:
            print(f"Invalid distance between {path[i]} and {path[i + 1]}")
            return np.inf
        total_distance += distances[path[i], path[i + 1]]
    # Add the distance to return to the starting point
    if distances[path[-1], path[0]] == np.inf:
        print(f"Invalid distance between {path[-1]} and {path[0]}")
        return np.inf
    total_distance += distances[path[-1], path[0]]
    return total_distance

# Function to calculate memory usage
def calculate_memory_usage(conductivities):
    return conductivities.nbytes

# Plotting the best path
def plot_best_path(best_path, cities, dataset_name):
    path_coords = cities[best_path]
    plt.figure(figsize=(10, 6))
    plt.plot(path_coords[:, 0], path_coords[:, 1], 'o-', markersize=10)
    plt.plot([path_coords[-1, 0], path_coords[0, 0]], [path_coords[-1, 1], path_coords[0,
1]], 'o-', markersize=10)  # Connect last to first
    for i, coord in enumerate(path_coords):
        plt.annotate(str(i + 1), (coord[0], coord[1]))
    plt.title(f"Best Path - {dataset_name}")
    plt.xlabel("X Coordinate")
    plt.ylabel("Y Coordinate")
    plt.grid(True)
    plt.show()

# Plotting the best fitness over iterations
def plot_best_fitness(best_distances, dataset_name):
    plt.figure(figsize=(10, 6))
    plt.plot(best_distances, 'o-', markersize=5)
    plt.title(f"Best Fitness over Iterations - {dataset_name}")
    plt.xlabel("Iteration")
    plt.ylabel("Total Distance (Fitness)")
    plt.grid(True)
    plt.show()

# Plotting the paths over selected iterations
def plot_paths_over_iterations(all_paths, cities, selected_iterations, dataset_name):
    plt.figure(figsize=(10, 6))
    for i in selected_iterations:
        path_coords = cities[all_paths[i]]
        plt.plot(path_coords[:, 0], path_coords[:, 1], 'o-', markersize=5, label=f"Iteration {i}")
        plt.plot([path_coords[-1, 0], path_coords[0, 0]], [path_coords[-1, 1], path_coords[0, 1]], 'o-', markersize=5)  # Connect last to first
    plt.title(f"Paths at Selected Iterations - {dataset_name}")
    plt.xlabel("X Coordinate")
    plt.ylabel("Y Coordinate")
    plt.legend()
    plt.grid(True)
    plt.show()

# Simulation loop with best solution tracking and additional performance measures
def run_simulation(dataset_name):
    file_path = f'{dataset_name}.tsp'
    cities = np.array(load_coordinates(file_path))
    print(f"Loaded coordinates for {len(cities)} cities from {dataset_name}.")

    distances = calculate_distances(cities)
    print("Distance matrix:")
    print(distances)

    pressures = np.random.rand(len(cities)) * 10
    conductivities = np.ones_like(distances) * 0.01  # Initial small value for all conductivities

    decay_rate = 0.1
    k = 0.1
    m = 2
    epsilon = 1e-10

    num_iterations = 50
    best_fitness = np.inf
    best_path = None
    best_distances = []
    computation_times = []
    convergence_rates = []
    memory_usages = []
    all_solutions = []
    all_paths = []

    start_time = time.time()

    for iteration in range(num_iterations):
        iteration_start_time = time.time()

        fluxes = calculate_fluxes(pressures, conductivities, distances)
        pressures = update_pressures(pressures, fluxes)
        conductivities = update_conductivities(conductivities, fluxes, decay_rate, k, m)

        iteration_end_time = time.time()
        computation_times.append(iteration_end_time - iteration_start_time)

        conductivities = prune_connections(conductivities)
        current_path, current_fitness = extract_tsp_path_heuristic(distances)
        all_paths.append(current_path)
        all_solutions.append(current_fitness)

        if current_fitness < best_fitness:
            best_fitness = current_fitness
            best_path = current_path

        best_distances.append(best_fitness)
        convergence_rates.append(best_fitness)
        memory_usages.append(calculate_memory_usage(conductivities))

        # Print the length of the tour for the current best path
        if best_path is not None:
            tour_length = calculate_total_distance(best_path, distances)
            print(f"Iteration {iteration}, Best Path Length: {tour_length}")

    total_computation_time = time.time() - start_time

    print("Best Fitness:", best_fitness)
    print("Best Path:", best_path)
    print("Total Computation Time:", total_computation_time, "seconds")
    print("Average Computation Time per Iteration:", np.mean(computation_times), "seconds")
    print("Memory Usage:", memory_usages[-1], "bytes")

    # Plot the fitness (total distance) over iterations to visualize the convergence.
    plot_best_fitness(best_distances, dataset_name)

    # Plot the best path found during the iterations.
    plot_best_path(best_path, cities, dataset_name)

    # Plot the paths over selected iterations
    selected_iterations = list(range(0, num_iterations, 10))
    plot_paths_over_iterations(all_paths, cities, selected_iterations, dataset_name)

# Run simulations for each dataset
datasets = ['st70', 'ulysses22', 'ch150']
for dataset in datasets:
    run_simulation(dataset)

"""## TSP WITH dynamic programming"""

import numpy as np
import gzip
import shutil
import matplotlib.pyplot as plt
import time
from python_tsp.exact import solve_tsp_dynamic_programming

# Function to extract .gz file
def extract_gzip(source_filepath, destination_filepath):
    with gzip.open(source_filepath, 'rb') as f_in, open(destination_filepath, 'wb') as f_out:
        shutil.copyfileobj(f_in, f_out)

# Function to load coordinates from the .tsp file
def load_coordinates(file_path):
    coordinates = []
    start_reading = False
    with open(file_path, 'r') as file:
        for line in file:
            if "NODE_COORD_SECTION" in line:
                start_reading = True
            elif "EOF" in line:
                break
            elif start_reading:
                parts = line.strip().split()
                if len(parts) == 3 and parts[0].isdigit():
                    coordinates.append((float(parts[1]), float(parts[2])))
    return coordinates

# Function to calculate geographical distances using the Haversine formula
def haversine(coord1, coord2):
    R = 6371.0  # Radius of the Earth in km
    lat1, lon1 = np.radians(coord1)
    lat2, lon2 = np.radians(coord2)
    dlat = lat2 - lat1
    dlon = lon2 - lon1
    a = np.sin(dlat / 2)**2 + np.cos(lat1) * np.cos(lat2) * np.sin(dlon / 2)**2
    c = 2 * np.arctan2(np.sqrt(a), np.sqrt(1 - a))
    distance = R * c
    return distance

# Function to calculate fluxes
def calculate_fluxes(pressures, conductivities, distances, epsilon=1e-10):
    num_cities = len(pressures)
    fluxes = np.zeros((num_cities, num_cities))
    for i in range(num_cities):
        for j in range(num_cities):
            if i != j:
                distance = max(distances[i][j], epsilon)  # Avoid division by zero
                delta_p = np.clip(pressures[i] - pressures[j], -1e3, 1e3)  # Ensure pressures do not cause overflow
                fluxes[i][j] = (conductivities[i][j] / distance) * delta_p
    return fluxes

# Function to update conductivities
def update_conductivities(conductivities, fluxes, decay_rate, k, m):
    num_cities = len(conductivities)
    for i in range(num_cities):
        for j in range(num_cities):
            if i != j:
                flux = np.clip(abs(fluxes[i][j]), 0, 1e3)  # Control the size of the flux to prevent overflow
                growth = k * (flux ** m) - decay_rate * conductivities[i][j]
                growth = np.clip(growth, -1e2, 1e2)  # Limit the growth to prevent explosive updates
                conductivities[i][j] += growth + np.random.rand() * 0.001  # Add randomness to explore more paths
    return conductivities

def calculate_distances(cities):
     num_cities = len(cities)
     distances = np.zeros((num_cities, num_cities))
     for i in range(num_cities):
         for j in range(num_cities):
             if i != j:
                 distances[i, j] = haversine(cities[i], cities[j])
             else:
                 distances[i, j] = np.inf
     return distances

# distances = calculate_distances(cities)

# Function to update pressures
def update_pressures(pressures, fluxes, rate=0.05):
    num_cities = len(pressures)
    for i in range(num_cities):
        net_influx = np.sum(fluxes[:, i]) - np.sum(fluxes[i, :])
        pressures[i] += rate * net_influx
        pressures[i] = np.clip(pressures[i], 0, 1e2)  # Prevent pressure from becoming negative or excessively high
    return pressures

# Function to prune connections
def prune_connections(conductivities, threshold=0.005):
    conductivities[conductivities < threshold] = 0
    return conductivities

# Function to extract a TSP path using python-tsp
def extract_tsp_path(conductivities, distances):
    adjusted_distances = np.where(conductivities > 0, distances, np.inf)
    permutation, distance = solve_tsp_dynamic_programming(adjusted_distances)
    return permutation, distance

# Function to calculate the total distance of a given path
def calculate_total_distance(path, distances):
    total_distance = 0
    for i in range(len(path) - 1):
        if distances[path[i], path[i + 1]] == np.inf:
            print(f"Invalid distance between {path[i]} and {path[i + 1]}")
            return np.inf
        total_distance += distances[path[i], path[i + 1]]
    # Add the distance to return to the starting point
    if distances[path[-1], path[0]] == np.inf:
        print(f"Invalid distance between {path[-1]} and {path[0]}")
        return np.inf
    total_distance += distances[path[-1], path[0]]
    return total_distance

# Function to calculate memory usage
def calculate_memory_usage(conductivities):
    return conductivities.nbytes

# Function to plot the best path
def plot_best_path(best_path, cities, dataset_name):
    path_coords = cities[best_path]
    plt.figure(figsize=(10, 6))
    plt.plot(path_coords[:, 0], path_coords[:, 1], 'o-', markersize=10)
    plt.plot([path_coords[-1, 0], path_coords[0, 0]], [path_coords[-1, 1], path_coords[0, 1]], 'o-', markersize=10)  # Connect last to first
    for i, coord in enumerate(path_coords):
        plt.annotate(str(i + 1), (coord[0], coord[1]))
    plt.title(f"Best Path for {dataset_name}")
    plt.xlabel("X Coordinate")
    plt.ylabel("Y Coordinate")
    plt.grid(True)
    plt.show()

# Function to plot the fitness over iterations
def plot_fitness_over_iterations(all_fitness, dataset_name):
    plt.figure(figsize=(10, 6))
    plt.plot(all_fitness, 'o-', markersize=5)
    plt.title(f"Fitness over Iterations for {dataset_name}")
    plt.xlabel("Iteration")
    plt.ylabel("Total Distance (Fitness)")
    plt.grid(True)
    plt.show()

# Simulation loop function
def run_simulation(dataset_name):
    # Extract and load city coordinates
    source_filepath = f'{dataset_name}.tsp.gz'
    destination_filepath = f'{dataset_name}.tsp'
    extract_gzip(source_filepath, destination_filepath)
    cities = np.array(load_coordinates(destination_filepath))
    print(f"Loaded coordinates for {len(cities)} cities from {dataset_name}.")

    distances = calculate_distances(cities)
    print("Distance matrix:")
    print(distances)

    # Initialize pressures and conductivities
    pressures = np.random.rand(len(cities)) * 10
    conductivities = np.ones_like(distances) * 0.01  # Initial small value for all conductivities

    decay_rate = 0.1
    k = 0.1
    m = 2
    epsilon = 1e-10

    num_iterations = 50
    best_fitness = np.inf
    best_path = None
    best_distances = []
    computation_times = []
    convergence_rates = []
    memory_usages = []
    all_solutions = []
    all_paths = []

    start_time = time.time()

    for iteration in range(num_iterations):
        iteration_start_time = time.time()

        # Calculate fluxes based on current pressures and conductivities.
        fluxes = calculate_fluxes(pressures, conductivities, distances)

        # Update pressures based on the calculated fluxes.
        pressures = update_pressures(pressures, fluxes)

        # Update conductivities based on the fluxes.
        conductivities = update_conductivities(conductivities, fluxes, decay_rate, k, m)

        iteration_end_time = time.time()
        computation_times.append(iteration_end_time - iteration_start_time)

        # Prune connections with low conductivities to remove inefficient paths.
        conductivities = prune_connections(conductivities)

        # Extract the TSP path using the adjusted distance matrix.
        current_path, current_fitness = extract_tsp_path(conductivities, distances)
        all_paths.append(current_path)
        all_solutions.append(current_fitness)

        # Update the best path and fitness if the current fitness is better.
        if current_fitness < best_fitness:
            best_fitness = current_fitness
            best_path = current_path

        best_distances.append(best_fitness)
        convergence_rates.append(best_fitness)
        memory_usages.append(calculate_memory_usage(conductivities))

        # Print the length of the tour for the current best path
        if best_path is not None:
            tour_length = calculate_total_distance(best_path, distances)
            print(f"Iteration {iteration}, Best Path Length: {tour_length}")

    total_computation_time = time.time() - start_time

    print(f"Best Fitness for {dataset_name}:", best_fitness)
    print("Best Path:", best_path)
    print("Total Computation Time:", total_computation_time, "seconds")
    print("Average Computation Time per Iteration:", np.mean(computation_times), "seconds")
    print("Memory Usage:", memory_usages[-1], "bytes")

    # Plot the fitness (total distance) over iterations to visualize the convergence.
    plot_fitness_over_iterations(all_solutions, dataset_name)

    # Plot the best path found during the iterations.
    plot_best_path(best_path, cities, dataset_name)

# Run simulations for each dataset
datasets = ['st70', 'ulysses22', 'ch150']
for dataset in datasets:
    run_simulation(dataset)